# 2020.10.5 hello springMVC

## servlet

1. 主要依赖

```xml
<dependencies>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.12</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-webmvc</artifactId>
            <version>5.2.9.RELEASE</version>
        </dependency>
        <dependency>
            <groupId>javax.servlet</groupId>
            <artifactId>servlet-api</artifactId>
            <version>2.5</version>
        </dependency>
        <dependency>
            <groupId>javax.servlet.jsp</groupId>
            <artifactId>jsp-api</artifactId>
            <version>2.2</version>
        </dependency>
        <dependency>
            <groupId>javax.servlet</groupId>
            <artifactId>jstl</artifactId>
            <version>1.2</version>
        </dependency>
    </dependencies>
```

2. 创建项目并设置他为web项目

![image-20201006165757995](/Users/juzelong/Documents/image-20201006165757995.png)

3. 创建完毕后，会出现webinf文件夹

![image-20201006165905546](/Users/juzelong/Documents/image-20201006165905546.png)

4. 继承sevrlet类并重写方法

![image-20201006170030703](/Users/juzelong/Documents/image-20201006170030703.png)

5. web.xml添加配置

```xml
    <servlet>
        <servlet-name>hello</servlet-name>
        <servlet-class>com.ju.servlet.HelloServlet</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>hello</servlet-name>
        <url-pattern>/hello</url-pattern>
    </servlet-mapping>
```

6. 添加tomcat服务器

![image-20201006170132326](/Users/juzelong/Documents/image-20201006170132326.png)

7. 添加jsp页面

![image-20201006170220043](/Users/juzelong/Documents/image-20201006170220043.png)

8. 效果:

![image-20201006170248164](/Users/juzelong/Documents/image-20201006170248164.png)



# 2020.10.9 springMvc原理理解

> 继续我的springmvc之旅

## springmvc原理型搭建

1. 依赖同上，设置项目为web项目
2. web.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">

    <servlet>
        <servlet-name>springmvc</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>classpath:springmvc-servlet.xml</param-value>
        </init-param>

        <load-on-startup>1</load-on-startup>
    </servlet>
    
    <servlet-mapping>
        <servlet-name>springmvc</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>
    
</web-app>
```

3. resources/springmvc-servlet.xml

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<beans xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"/>
    <bean class="org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"/>
    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver" id="InternalResourceViewResolver">
        <!-- 前缀 -->
        <property name="prefix" value="/WEB-INF/jsp/"/>
        <!-- 后缀 -->
        <property name="suffix" value=".jsp"/>
    </bean>

    <bean id="/hello" class="com.ju.controller.HelloController"/>

</beans>
```

4. helloController

```java
package com.ju.controller;

import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.mvc.Controller;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class HelloController implements Controller {

    public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception {
        ModelAndView mv = new ModelAndView();

        mv.addObject("msg", "HelloSpringMvc");
        mv.setViewName("hello");  //WEB-INF/jsp/hello.jsp

        return mv;
    }
}

```

5. ![image-20201009145157775](/Users/juzelong/Documents/image-20201009145157775.png)

> springmvc的本质是基于spring，然后让开发者摆脱servlet的使用，更专注于业务。

> 整个的springmvc的处理流程如下
>
> 1.请求dispatcherservlet
>
> 2.根据分发的url地址寻找处理映射器hadleMapping
>
> 3.找到后返回给dispatcherservlet，并发送给处理适配器handleAdapter,找到controller执行并返回modelandview
>
> 4.拿到modelandview调用视图适配器viewResolever
>
> 5.渲染显示视图

![image-20201009150537587](/Users/juzelong/Documents/image-20201009150537587.png)



## Springmvc的注解形式开发

1. 依赖如上，设置项目为web项目
2. Web.xml和之前的没有区别
3. Springmvc-servlet.xml

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<beans xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/mvc
       https://www.springframework.org/schema/mvc/spring-mvc.xsd">

    <!-- 自动扫描包 -->
    <context:component-scan base-package="com.ju.controller"/>
    <!-- spring不处理静态资源 -->
    <mvc:default-servlet-handler />

    <mvc:annotation-driven />
    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver" id="internalResourceViewResolver">
        <!-- 前缀 -->
        <property name="prefix" value="/WEB-INF/jsp/" />
        <property name="suffix" value=".jsp"/>
    </bean>
</beans>
```

4. HelloController

```java
package com.ju.controller;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class helloController {

    @RequestMapping("/hello")
    public String hello(Model model) {
        model.addAttribute("msg", "helloSpring Mvc");
        return "hello";
    }
}
```

5. 记得项目结构中增加lib包

> 总的来说现在所有的开发基本都是基于注解，原理型算是了解一下机制，注解则是省掉了非常多的步骤，跳步骤的代价就是很多东西似懂非懂。

## requestMapping的一些传参方式

```java
    @RequestMapping(value = "/h/{a}/{b}",method = RequestMethod.GET)
    public String h(@PathVariable String a, @PathVariable String b, Model model) {
        model.addAttribute("a", a);
        model.addAttribute("b", b);
        return "h";
    }
```

> 重定向

```java
return "redirect:hello";
```

> 接受各种参数的方式

```java

    @GetMapping("/user")
    public String user(User user, Model model) {
        model.addAttribute("msg", user.getName());
        return "hello";
    }

    @GetMapping("/user2")
    public String user2(@RequestParam("username") String name, Model model) {
        model.addAttribute("msg", name);
        return "hello";
    }
```

# 2020.10.10 整个ssm项目（未完）

## spring jackson

1. 导入依赖

```xml
<dependencies>
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
            <version>2.11.0</version>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>1.18.12</version>
        </dependency>
    </dependencies>
```

2. 全局解决乱码

```xml
<mvc:annotation-driven >
        <mvc:message-converters register-defaults="true">
            <bean class="org.springframework.http.converter.StringHttpMessageConverter">
                <constructor-arg value="utf-8"/>
            </bean>
            <bean class="org.springframework.http.converter.json.MappingJackson2HttpMessageConverter">
                <property name="objectMapper">
                    <bean class="org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean">
                        <property name="failOnEmptyBeans" value="false"/>
                    </bean>
                </property>
            </bean>
        </mvc:message-converters>
    </mvc:annotation-driven>
```

3. ![image-20201010105111378](/Users/juzelong/Documents/image-20201010105111378.png)

4. 工具类

```java
public class jsonUtils {

    public String getJson(Object o) throws JsonProcessingException {
        ObjectMapper objectMapper = new ObjectMapper();
        //将json中的Date不自动转为时间戳
        objectMapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);
        //将json中的日期格式写成我们自定义的格式
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        objectMapper.setDateFormat(sdf);
        return objectMapper.writeValueAsString(o);
    }
}
```

5. 效果

![image-20201010105644730](/Users/juzelong/Documents/image-20201010105644730.png)

## 项目大整合 1

> 这次搭建真的是天昏地暗，日月无光，到处都是坑，一步一步往前挪。。。

1. 依赖

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.ju</groupId>
    <artifactId>springmvc-mybatis</artifactId>
    <packaging>pom</packaging>
    <version>1.0-SNAPSHOT</version>
    <modules>
        <module>mybatis</module>
    </modules>

    <dependencies>
        <!-- 测试 -->
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.12</version>
            <scope>test</scope>
        </dependency>
        <!-- mysql -->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>8.0.21</version>
        </dependency>
        <dependency>
            <groupId>com.mchange</groupId>
            <artifactId>c3p0</artifactId>
            <version>0.9.5.2</version>
        </dependency>

        <!-- servlet -->
        <dependency>
            <groupId>javax.servlet</groupId>
            <artifactId>servlet-api</artifactId>
            <version>2.5</version>
        </dependency>
        <dependency>
            <groupId>javax.servlet.jsp</groupId>
            <artifactId>jsp-api</artifactId>
            <version>2.2</version>
        </dependency>
        <dependency>
            <groupId>javax.servlet</groupId>
            <artifactId>jstl</artifactId>
            <version>1.2</version>
        </dependency>
        <!-- mybatis -->
        <dependency>
            <groupId>org.mybatis</groupId>
            <artifactId>mybatis</artifactId>
            <version>3.5.2</version>
        </dependency>
        <dependency>
            <groupId>org.mybatis</groupId>
            <artifactId>mybatis-spring</artifactId>
            <version>2.0.2</version>
        </dependency>
        <!-- spring -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-webmvc</artifactId>
            <version>5.2.9.RELEASE</version>
        </dependency>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-jdbc</artifactId>
            <version>5.2.9.RELEASE</version>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>1.18.12</version>
        </dependency>

    </dependencies>

    <!-- 静态资源导出问题 -->
    <build>
        <resources>
            <resource>
                <directory>src/main/java</directory>
                <includes>
                    <include>**/*.properties</include>
                    <include>**/*.xml</include>
                </includes>
                <filtering>false</filtering>
            </resource>
            <resource>
                <directory>src/main/resources</directory>
                <includes>
                    <include>**/*.properties</include>
                    <include>**/*.xml</include>
                </includes>
                <filtering>false</filtering>
            </resource>
        </resources>
    </build>

</project>
```

> **请一定记住，java中不同的版本的包是可能不兼容的，比如spring-webmvc的5.x版本只能用5.x版本的spring-jdbc**
>
> **另外，com.mysql.cj.jdbc.Driver的数据库引擎只能用于8.0以上的mysql版本**

2. 由于是ssm，绝大多数的配置都交给了spring，因此mybatis的配置并不多.  mybatis-config.xml

   ```xml
   <?xml version="1.0" encoding="UTF-8" ?>
   <!DOCTYPE configuration
           PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
           "http://mybatis.org/dtd/mybatis-3-config.dtd">
   <configuration>
       <!-- 引入外部配置文件 -->
       <properties resource="database.properties" />
   
       <typeAliases>
           <package name="com.ju.pojo"/>
       </typeAliases>
   
       <mappers>
           <!--<mapper resource="com/ju/dao/bookMapper.xml"/>-->
           <mapper class="com.ju.dao.BookMapper" />
           <!--<package name="com.ju.dao"/>-->
       </mappers>
   
   </configuration>
   ```

3. Spring-dao.xml和database.properties

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd">


<context:property-placeholder location="classpath:database.properties" />

    <!-- 2. 连接池
        dbcp: 半自动化  不能自动连接
        c3p0：自动化操作 自动化加载配置文件，并可以设置到对象中
        druid
        hikari
    -->
    <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
        <property name="driverClass" value="${driver}"/>
        <property name="jdbcUrl" value="${url}"/>
        <property name="user" value="${username}"/>
        <property name="password" value="${password}"/>

        <!-- 连接池大小 -->
        <property name="maxPoolSize" value="30"/>
        <property name="minPoolSize" value="10"/>
        <!-- 关闭连接后不自动commit -->
        <property name="autoCommitOnClose" value="false"/>
        <!-- 自动超时时间 -->
        <property name="checkoutTimeout" value="10000"/>
        <!-- 获取连接失败后的重试次数 -->
        <property name="acquireRetryAttempts" value="2"/>
    </bean>

    <!-- 3.sqlSessionFactory -->
    <bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
        <property name="dataSource" ref="dataSource"/>
        <!-- 绑定mybatis的配置文件 -->
        <property name="configLocation" value="classpath:mybatis-config.xml"/>
    </bean>

    <!--4.dao接口扫描包 动态注入到spring-->
    <bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
        <!-- 注入sqlSessionFactory -->
        <property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"/>
        <!-- 要扫描dao包 -->
        <property name="basePackage" value="com.ju.dao"/>
    </bean>


</beans>
```

```xml
driver=com.mysql.cj.jdbc.Driver
##mysql8.0需要增加时区
url=jdbc:mysql://localhost:3306/mybatis?useSSL=false&serverTimezone=GMT%2B8&characterEncoding=utf8&rewriteBatchedStatements=true
username=root
password=xiaomusi520
```

4. Spring-mvc.xml

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/mvc
       http://www.springframework.org/schema/mvc/spring-mvc.xsd">

    <!-- 1. 注解驱动 -->
    <mvc:annotation-driven/>
    <!-- 2. 静态资源过滤-->
    <mvc:default-servlet-handler/>
    <!-- 3.扫描包:controller-->
    <context:component-scan base-package="com.ju.controller"/>
    <!-- 4.视图解析器-->
    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <property name="prefix" value="/WEB-INF/jsp"/>
        <property name="suffix" value=".jsp"/>
    </bean>

</beans>
```

5. Spring-service.xml

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd">

    <!-- 1.扫描service下的包 -->
    <context:component-scan base-package="com.ju.service"/>

    <!-- 2.将所有业务类注入spring 可以通过注解或者配置实现 -->
    <bean id="BookServiceImpl" class="com.ju.service.BookServiceImpl">
        <property name="bookMapper" ref="bookMapper"/>
    </bean>

    <!--3.声明式事物 -->
    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <!-- 注入数据源 -->
        <property name="dataSource" ref="dataSource"/>
    </bean>

    <!-- 4. aop事物支持 -->

</beans>
```

6. 将所有的文件融合

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd">

    <import resource="classpath:spring-mvc.xml"/>
    <import resource="classpath:spring-service.xml"/>
    <import resource="classpath:spring-dao.xml"/>
</beans>
```

7. 将项目设置成web项目 并设置web,xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">
    <!-- DispatchServlet -->
    <servlet>
        <servlet-name>springmvc</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>classpath:applicationContext.xml</param-value>
        </init-param>
        <!-- 和tomcat一起启动 -->
        <load-on-startup>1</load-on-startup>
    </servlet>
    
    <servlet-mapping>
        <servlet-name>springmvc</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>

    <!-- 乱码过滤 -->
    <filter>
        <filter-name>EncodingFilter</filter-name>
        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
        <init-param>
            <param-name>encoding</param-name>
            <param-value>utf-8</param-value>
        </init-param>
    </filter>
    <filter-mapping>
        <filter-name>EncodingFilter</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>

    <!-- session -->
    <session-config>
        <session-timeout>15</session-timeout>
    </session-config>

</web-app>
```



8. ![image-20201010182246501](/Users/juzelong/Documents/image-20201010182246501.png)

9. 至此，可以开始coding了。

![image-20201010182404111](/Users/juzelong/Documents/image-20201010182404111.png)

> 只要有叶子，就有希望了。

# 2020.10.12 cis的简单调研

## 项目大整合2

> 原本周五已经整合的差不多了，但是还有一些报错，今天继续

![image-20201012102953620](/Users/juzelong/Documents/image-20201012102953620.png)

> 除了以上的问题我还遇到了很多其他问题：
>
> **classpath:**database.properties
>
> 这个的意思是会去查找resource目录下的资源文件，web.xml插入的时候会有问题



## cis系统调研

> 这个调研的目的主要是看是否可以适配我们的燃气云系统

> 关于原系统的功能梳理

1. 所有户号初始绑定在我看来，原先应该就在tcis里有过记录，不然的话手机号和地址，以及身份证是出不来相应的户号选择框的。
2. 当你绑定了户号以后，他们就会切换到当地的地区为你服务
3. 主要需要观察的信息就2个，1个是缴费流程，1个是对账明细。

> 如何才能说明cis可以胜任？我个人感觉只要tcis3.0的文档中所有的接口 都可以满足的情况下，就有希望！

# 2020.10.13 hi springboot

## hello～springBoot～long time no see, nice to meet u again

1. ![image-20201013111151770](/Users/juzelong/Documents/image-20201013111151770.png)
2. ![image-20201013111206894](/Users/juzelong/Documents/image-20201013111206894.png)
3. ![image-20201013111218372](/Users/juzelong/Documents/image-20201013111218372.png)
4. ![image-20201013111234210](/Users/juzelong/Documents/image-20201013111234210.png)

5. ![image-20201013114647082](/Users/juzelong/Documents/image-20201013114647082.png)

> 整个配置非常简单，自动装配，直接使用!

## 热部署简单设置

https://blog.csdn.net/duanaibing3017/article/details/88727045





## 关于springboot自动装配的原理

![image-20201013150537496](/Users/juzelong/Documents/image-20201013150537496.png)

> 第一遍真的是云里雾里，等后面的课程听完再回来跟着一起走一遍



## 关于springboot配置yaml的一些简单知识

![image-20201013154551256](/Users/juzelong/Documents/image-20201013154551256.png)

1. 关于配置文件的赋值问题： 

```yml
server:
  port: 8081

person:
  name: juzelong
  age: 10
  birthday: 1988/03/18
  m:
    - 1
    - 2
  map: {j: u, z: d}
  dog:
    name: xiaohou
    age: 3
```

```java
package com.ju.bootdemo.pojo;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

import java.util.Date;
import java.util.List;
import java.util.Map;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Component
@ConfigurationProperties("person")
public class Person {
    private String name;
    private int age;
    private Date birthday;
    private List<Integer> m;
    private Map<String, String> map;
    private Dog dog;
}
```

> 关键字是@ConfigurationProperties("person") 他连接了2个资源

![image-20201013170614784](/Users/juzelong/Documents/image-20201013170614784.png)



## JSR303校验

```xml
package com.ju.bootdemo.pojo;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;
import org.springframework.validation.annotation.Validated;


import javax.validation.constraints.Email;
import java.util.Date;
import java.util.List;
import java.util.Map;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Component
@Validated
@ConfigurationProperties("person")
public class Person {
    @Email(message = "邮件不正确")
    private String name;
    private int age;
    private Date birthday;
    private List<Integer> m;
    private Map<String, String> map;
    private Dog dog;
}
```

```xml
<dependency>
            <groupId>javax.validation</groupId>
            <artifactId>validation-api</artifactId>
        </dependency>
        <dependency>
            <groupId>org.hibernate.validator</groupId>
            <artifactId>hibernate-validator</artifactId>
        </dependency>
```



## springboot多环境配置 yaml简单版本

```xml
spring:
  profiles:
    active: dev

---
server:
  port: 8081
spring:
  profiles: dev

---
server:
  port: 8082
spring:
  profiles: ol
```

> 简直不能更简单！一个文件全部搞定

# 2020.10.14

## springboot配置文件简单解释

![image-20201014101001412](/Users/juzelong/Documents/image-20201014101001412.png)

![image-20201014104400065](/Users/juzelong/Documents/image-20201014104400065.png)

>  原理类的东西暂时先放到这里，有机会还需要回去再看的

## 搭建一个springboot的web项目

1. 引入静态资源

![image-20201014113704007](/Users/juzelong/Documents/image-20201014113704007.png)

## thymeleaf模版引擎 

1. 导入依赖

```xml
<dependency>
			<groupId>org.thymeleaf</groupId>
			<artifactId>thymeleaf-spring5</artifactId>
		</dependency>
		<dependency>
			<groupId>org.thymeleaf.extras</groupId>
			<artifactId>thymeleaf-extras-java8time</artifactId>
		</dependency>
```

2. 关于基本的配置

```java
private static final Charset DEFAULT_ENCODING = StandardCharsets.UTF_8;

	public static final String DEFAULT_PREFIX = "classpath:/templates/";

	public static final String DEFAULT_SUFFIX = ".html";
```

> 从上述的配置来看，只要将文件放到templates下，就可以做到跳转页面的功能

3. controller

```java
package com.ju.springboot03.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class HelloController {

    @RequestMapping("/test")
    public String hello(){
        return "test";
    }

}
```

4. template

![image-20201014143746354](/Users/juzelong/Documents/image-20201014143746354.png)

## thymeleaf模版引擎的一些简单语法

```html
<div th:text="${msg}"></div>

<div th:each="user:${array}" th:text="${user}"></div>
```



## springboot整合JDBC 

1. 直接在创建项目的时候就可以选择依赖

```xml
<dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-jdbc</artifactId>
        </dependency>

```

2. 直接就可以开始玩查询了。。。简直不能再简单

```java
 @Autowired
    JdbcTemplate jdbcTemplate;

    @RequestMapping("/hello")
    public String getHello() {
        String sql = "select * from student";
        List<Map<String, Object>> maps = jdbcTemplate.queryForList(sql);

        return  JSON.toJSONString(maps);
    }
```

## 整合druid

1. 引入依赖

```xml
        <!-- https://mvnrepository.com/artifact/com.alibaba/druid -->
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>druid</artifactId>
            <version>1.2.1</version>
        </dependency>

        <dependency>
            <groupId>log4j</groupId>
            <artifactId>log4j</artifactId>
            <version>1.2.17</version>
        </dependency>
```

> 插一句，绝大多数自由配置都是写在这里，xxxConfig

![image-20201015102555900](/Users/juzelong/Documents/image-20201015102555900.png)

> @ConfigurationProperties(prefix = "spring.datasource") 将会读取配置文件下的内容

```java
package com.ju.springboot04.config;

import com.alibaba.druid.pool.DruidDataSource;
import com.alibaba.druid.support.http.StatViewFilter;
import com.alibaba.druid.support.http.StatViewServlet;
import com.alibaba.druid.support.http.WebStatFilter;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.web.servlet.FilterRegistrationBean;
import org.springframework.boot.web.servlet.ServletRegistrationBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import javax.sql.DataSource;
import java.util.HashMap;

@Configuration
public class DruidConfig {

    @ConfigurationProperties(prefix = "spring.datasource")
    @Bean
    public DataSource druidDataSource() {
        return new DruidDataSource();
    }

    //后台监控 web.xml
    @Bean
    public ServletRegistrationBean statViewServlet() {
        ServletRegistrationBean bean = new ServletRegistrationBean<>(new StatViewServlet(), "/druid/*");

        HashMap<String, String> initParameters = new HashMap<>();
        //增加配置
        initParameters.put("loginUsername", "admin");
        initParameters.put("loginPassword", "123456");

        //允许谁可以访问
        initParameters.put("allow", "");

        //禁止访问
        initParameters.put("juzelong", "192.168.1.112");

        bean.setInitParameters(initParameters);

        return bean;

    }

    //filter
    @Bean
    public FilterRegistrationBean webStatFilter(){
        FilterRegistrationBean bean = new FilterRegistrationBean();
        bean.setFilter(new WebStatFilter());
        HashMap<String, String> initParameters = new HashMap<>();

        initParameters.put("exclusions", "*.js,*.css,/druid/*");

        bean.setInitParameters(initParameters);
        return bean;
    }
}
```

> 文件的名字和位置基本都定死的

![image-20201015102812067](/Users/juzelong/Documents/image-20201015102812067.png)

2. 以上配置完成了以后，就可以直接访问了 localhost:8081/druid

![image-20201015102938782](/Users/juzelong/Documents/image-20201015102938782.png)

# 2020.10.15 继续了解集成

## springboot集成mybatis

1. 引入依赖

```xml
<dependency>
            <groupId>org.mybatis.spring.boot</groupId>
            <artifactId>mybatis-spring-boot-starter</artifactId>
            <version>2.1.3</version>
        </dependency>

        <dependency>
            <groupId>log4j</groupId>
            <artifactId>log4j</artifactId>
            <version>1.2.17</version>
        </dependency>
```

2. 配置路径

```yaml
#整合mybatis
mybatis:
  type-aliases-package: com.ju.springboot04.pojo
  mapper-locations: classpath:mybatis/mapper/*.xml
```

3. 配置路径

![image-20201015120328199](/Users/juzelong/Documents/image-20201015120328199.png)

4. helloController.java

```java
package com.ju.springboot04.controller;

import com.alibaba.fastjson.JSON;
import com.ju.springboot04.Mapper.UserMapper;
import com.ju.springboot04.pojo.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;
import java.util.Map;

@RestController
public class HelloController {

    @Autowired
    JdbcTemplate jdbcTemplate;

    @Autowired
    UserMapper userMapper;

    @RequestMapping("/hello")
    public String getHello() {
        String sql = "select * from student";
        List<Map<String, Object>> maps = jdbcTemplate.queryForList(sql);

        return  JSON.toJSONString(maps);
    }


    @RequestMapping("/hello2")
    public String getUserList() {
        List<User> userList = userMapper.getUserList();
        return  JSON.toJSONString(userList);
    }


}
```

5. UserMapper.java

```java
package com.ju.springboot04.Mapper;

import com.ju.springboot04.pojo.User;
import org.apache.ibatis.annotations.Mapper;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
@Mapper
public interface UserMapper {
    List<User> getUserList();
}

```

6. User.java

```java
package com.ju.springboot04.pojo;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class User {
    private Integer id;

    private String name;

    private String pwd;
}
```

7. UserMapper.xml

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.ju.springboot04.Mapper.UserMapper">
    <!-- 开启二级缓存 -->
    <cache
            eviction="FIFO"
            flushInterval="60000"
            size="512"
            readOnly="true"/>

    <select id="getUserList" resultType="com.ju.springboot04.pojo.User">
        select * from mybatis.user;
    </select>
</mapper>
```

## spring集成springSecurity

1. 导入依赖

```xml
<dependency>
            <groupId>org.thymeleaf</groupId>
            <artifactId>thymeleaf-spring5</artifactId>
        </dependency>
        <dependency>
            <groupId>org.thymeleaf.extras</groupId>
            <artifactId>thymeleaf-extras-java8time</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
```

2. 控制器

```java
package com.ju.springboot05security.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class RouteController {

    @RequestMapping({"/", "index"})
    public String index() {
        return "index";
    }


    @RequestMapping("/toLogin")
    public String login() {
        return "login";
    }


    @RequestMapping("/level1/{id}")
    public String level1(@PathVariable Integer id) {
        return "views/level1/" + id.toString();
    }

    @RequestMapping("/level2/{id}")
    public String level2(@PathVariable Integer id) {
        return "views/level2/" + id.toString();
    }

    @RequestMapping("/level3/{id}")
    public String level3(@PathVariable Integer id) {
        return "views/level3/" + id.toString();
    }

}
```

3. **核心** SecurityConfig

```java
package com.ju.springboot05security.config;

import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;

@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    //授权
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        //请求授权规则
        http.authorizeRequests()
                .antMatchers("/").permitAll()
                .antMatchers("/level1/**").hasRole("vip1")
                .antMatchers("/level2/**").hasRole("vip2")
                .antMatchers("/level3/**").hasRole("vip3");

        //错误返回登陆页
        http.formLogin();
        //开启注销
        http.logout();

    }

    //认证
    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder())
                .withUser("juzelong")
                .password(new BCryptPasswordEncoder().encode("xiaomusi"))
                .roles("vip1", "vip2")
                .and().withUser("root").password(new BCryptPasswordEncoder().encode("123")).roles("vip3");

    }
}

```

> 总的来说，配置简单的令人发指。。非常容易就可以配置出一个权限管理

## 初识shiro

> 官网是主要的信息来源

1. 引入依赖

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>spring-boot-shiro</artifactId>
        <groupId>org.example</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <artifactId>hello-shiro</artifactId>

    <dependencies>
        <dependency>
            <groupId>org.apache.shiro</groupId>
            <artifactId>shiro-core</artifactId>
            <version>1.6.0</version>
        </dependency>

        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>jcl-over-slf4j</artifactId>
            <version>1.7.25</version>
        </dependency>

        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-log4j12</artifactId>
            <version>1.7.26</version>
        </dependency>

        <dependency>
            <groupId>log4j</groupId>
            <artifactId>log4j</artifactId>
            <version>1.2.17</version>
        </dependency>
    </dependencies>


</project>
```

2. 配置文件

```yaml
## log4j.properties
log4j.rootLogger=INFO, stdout

log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%d %p [%c] - %m %n

# General Apache libraries
log4j.logger.org.apache=WARN

# Spring
log4j.logger.org.springframework=WARN

# Default Shiro logging
log4j.logger.org.apache.shiro=INFO

# Disable verbose logging
log4j.logger.org.apache.shiro.util.ThreadContext=WARN
log4j.logger.org.apache.shiro.cache.ehcache.EhCache=WARN
```

```yaml
## shiro.ini
[users]
# user 'root' with password 'secret' and the 'admin' role
root = secret, admin
# user 'guest' with the password 'guest' and the 'guest' role
guest = guest, guest
# user 'presidentskroob' with password '12345' ("That's the same combination on
# my luggage!!!" ;)), and role 'president'
presidentskroob = 12345, president
# user 'darkhelmet' with password 'ludicrousspeed' and roles 'darklord' and 'schwartz'
darkhelmet = ludicrousspeed, darklord, schwartz
# user 'lonestarr' with password 'vespa' and roles 'goodguy' and 'schwartz'
lonestarr = vespa, goodguy, schwartz

# -----------------------------------------------------------------------------
# Roles with assigned permissions
#
# Each line conforms to the format defined in the
# org.apache.shiro.realm.text.TextConfigurationRealm#setRoleDefinitions JavaDoc
# -----------------------------------------------------------------------------
[roles]
# 'admin' role has all permissions, indicated by the wildcard '*'
admin = *
# The 'schwartz' role can do anything (*) with any lightsaber:
schwartz = lightsaber:*
# The 'goodguy' role is allowed to 'drive' (action) the winnebago (type) with
# license plate 'eagle5' (instance specific id)
goodguy = winnebago:drive:eagle5
```

3. java

```java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

import org.apache.shiro.SecurityUtils;
import org.apache.shiro.authc.*;
import org.apache.shiro.config.IniSecurityManagerFactory;
import org.apache.shiro.mgt.SecurityManager;
import org.apache.shiro.session.Session;
import org.apache.shiro.subject.Subject;
import org.apache.shiro.util.Factory;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


/**
 * Simple Quickstart application showing how to use Shiro's API.
 *
 * @since 0.9 RC2
 */
public class Quickstart {

    private static final transient Logger log = LoggerFactory.getLogger(Quickstart.class);


    public static void main(String[] args) {
        Factory<SecurityManager> factory = new IniSecurityManagerFactory("classpath:shiro.ini");
        SecurityManager securityManager = factory.getInstance();
        SecurityUtils.setSecurityManager(securityManager);

        // Now that a simple Shiro environment is set up, let's see what you can do:

        // get the currently executing user:
        Subject currentUser = SecurityUtils.getSubject();

        // Do some stuff with a Session (no need for a web or EJB container!!!)
        Session session = currentUser.getSession();
        session.setAttribute("someKey", "aValue");
        String value = (String) session.getAttribute("someKey");
        if (value.equals("aValue")) {
            log.info("Retrieved the correct value! [" + value + "]");
        }

        // let's login the current user so we can check against roles and permissions:
        if (!currentUser.isAuthenticated()) {
            UsernamePasswordToken token = new UsernamePasswordToken("lonestarr", "vespa");
            token.setRememberMe(true);
            try {
                currentUser.login(token);
            } catch (UnknownAccountException uae) {
                log.info("There is no user with username of " + token.getPrincipal());
            } catch (IncorrectCredentialsException ice) {
                log.info("Password for account " + token.getPrincipal() + " was incorrect!");
            } catch (LockedAccountException lae) {
                log.info("The account for username " + token.getPrincipal() + " is locked.  " +
                        "Please contact your administrator to unlock it.");
            }
            // ... catch more exceptions here (maybe custom ones specific to your application?
            catch (AuthenticationException ae) {
                //unexpected condition?  error?
            }
        }

        //say who they are:
        //print their identifying principal (in this case, a username):
        log.info("User [" + currentUser.getPrincipal() + "] logged in successfully.");

        //test a role:
        if (currentUser.hasRole("schwartz")) {
            log.info("May the Schwartz be with you!");
        } else {
            log.info("Hello, mere mortal.");
        }

        //test a typed permission (not instance-level)
        if (currentUser.isPermitted("lightsaber:wield")) {
            log.info("You may use a lightsaber ring.  Use it wisely.");
        } else {
            log.info("Sorry, lightsaber rings are for schwartz masters only.");
        }

        //a (very powerful) Instance Level permission:
        if (currentUser.isPermitted("winnebago:drive:eagle5")) {
            log.info("You are permitted to 'drive' the winnebago with license plate (id) 'eagle5'.  " +
                    "Here are the keys - have fun!");
        } else {
            log.info("Sorry, you aren't allowed to drive the 'eagle5' winnebago!");
        }

        //all done - log out!
        currentUser.logout();

        System.exit(0);
    }
}
```

> 快速启动观后感:感觉和spring-security差不多

# 2020.10.16 shiro！

## spring集成shiro和mybatis

> 关于thymeleaf的头文件

```html
<html lang="en" xmlns:th="http://www.thymeleaf.com/org">
```

![image-20201016135443054](/Users/juzelong/Documents/image-20201016135443054.png)

1. 目录结构

![image-20201019150103282](/Users/juzelong/Documents/image-20201019150103282.png)

2. pom依赖

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.3.4.RELEASE</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <groupId>com.ju</groupId>
    <artifactId>shiro-02</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>shiro-02</name>
    <description>Demo project for Spring Boot</description>

    <properties>
        <java.version>1.8</java.version>
    </properties>

    <dependencies>

        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>1.18.12</version>
        </dependency>

        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>8.0.21</version>
        </dependency>

        <dependency>
            <groupId>log4j</groupId>
            <artifactId>log4j</artifactId>
            <version>1.2.17</version>
        </dependency>

        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>druid</artifactId>
            <version>1.2.1</version>
        </dependency>

        <dependency>
            <groupId>org.mybatis.spring.boot</groupId>
            <artifactId>mybatis-spring-boot-starter</artifactId>
            <version>2.1.3</version>
        </dependency>


        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>org.apache.shiro</groupId>
            <artifactId>shiro-spring</artifactId>
            <version>1.6.0</version>
        </dependency>

        <dependency>
            <groupId>org.thymeleaf</groupId>
            <artifactId>thymeleaf-spring5</artifactId>
        </dependency>
        <dependency>
            <groupId>org.thymeleaf.extras</groupId>
            <artifactId>thymeleaf-extras-java8time</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
            <exclusions>
                <exclusion>
                    <groupId>org.junit.vintage</groupId>
                    <artifactId>junit-vintage-engine</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>

```

3.yaml配置

```yml
spring:
  datasource:
    username: root
    password: xiaomusi520
    url: jdbc:mysql://localhost:3306/mybatis?useSSL=false&serverTimezone=GMT%2B8&characterEncoding=utf8&rewriteBatchedStatements=true
    driver-class-name: com.mysql.cj.jdbc.Driver
    type: com.alibaba.druid.pool.DruidDataSource
    filters: stat,wall,log4j

server:
  port: 8081

#整合mybatis
mybatis:
  type-aliases-package: com.ju.shiro2.pojo
  mapper-locations: classpath:mybatis/mapper/*.xml
```

4. shiroConfig.java

```java
package com.ju.shiro02.config;

import org.apache.shiro.spring.web.ShiroFilterFactoryBean;
import org.apache.shiro.web.mgt.DefaultWebSecurityManager;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.LinkedHashMap;
import java.util.Map;

@Configuration
public class ShiroConfig {

    @Bean
    public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier("securityManager") DefaultWebSecurityManager defaultWebSecurityManager){
        ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean();
        //设置安全管理器
        bean.setSecurityManager(defaultWebSecurityManager);
        //anon  无需认证
        //authc 需要登陆
        //user  需要记住我
        //perms 需要要有权限
        //role  需要有角色
        Map<String, String> filterMap = new LinkedHashMap<>();

        filterMap.put("/usr/add", "perms[user:add]");

        filterMap.put("/usr/*", "authc");
        bean.setFilterChainDefinitionMap(filterMap);

        //设置登陆请求
        bean.setLoginUrl("/toLogin");

        //设置未授权的页面
        bean.setUnauthorizedUrl("/noauth");


        return bean;
    }

    @Bean(name = "securityManager")
    public DefaultWebSecurityManager getDefaultWebSecurityManager(@Qualifier("userRealm") UserRealm userRealm) {
        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();

        securityManager.setRealm(userRealm);
        return securityManager;
    }

    @Bean
    public UserRealm userRealm() {
        return new UserRealm();
    }

}

```

5. UserRealm.java

```java
package com.ju.shiro02.config;

import com.ju.shiro02.pojo.User;
import com.ju.shiro02.service.UserService;
import org.apache.shiro.SecurityUtils;
import org.apache.shiro.authc.*;
import org.apache.shiro.authz.AuthorizationInfo;
import org.apache.shiro.authz.SimpleAuthorizationInfo;
import org.apache.shiro.realm.AuthorizingRealm;
import org.apache.shiro.subject.PrincipalCollection;
import org.apache.shiro.subject.Subject;
import org.springframework.beans.factory.annotation.Autowired;

public class UserRealm extends AuthorizingRealm {
    @Autowired
    private UserService userService;

    //授权
    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {
        System.out.println("授权啦！！！===================");
        SimpleAuthorizationInfo simpleAuthorizationInfo = new SimpleAuthorizationInfo();
        //simpleAuthorizationInfo.addRole("user");
        //simpleAuthorizationInfo.addStringPermission("user:add");

        Subject subject = SecurityUtils.getSubject();
        User principal = (User) subject.getPrincipal();
        System.out.println(principal.getPerms());
        simpleAuthorizationInfo.addStringPermission(principal.getPerms());

        return simpleAuthorizationInfo;
    }

    //认证
    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {
        UsernamePasswordToken usernamePasswordToken =(UsernamePasswordToken) token;
        User userByName = userService.getUserByName(usernamePasswordToken.getUsername());

        if (userByName == null) {
            return null;
        }
        //校验并给予user对象
        return new SimpleAuthenticationInfo(userByName, userByName.getPwd(), "");
    }
}

```

> 总的来说，主要的文件就是shiroConfig.java和UserRealm.java，前者用来过滤url，后者用来认证和授权，具体的角色和权限可以参考代码

# 2020.10.19 dubbo

## springboot dubbo

> zookeeper基本命令 根目录 ***download***下
>
> 启动： ./zkServer.sh start
>
> 连接: ./zkCli.sh
>
> [zk: localhost:2181(CONNECTED) 8] create -e /juzelong 1
> Created /juzelong
> [zk: localhost:2181(CONNECTED) 9] get /juzelong
> 1

> Dubbo-admin 直接下载文件，通过maven编译
>
> /Users/juzelong/project/maven/apache-maven-3.6.3/bin/mvn clean package
>
> /Users/juzelong/project/maven/apache-maven-3.6.3/bin/mvn --projects dubbo-admin-server spring-boot:run
>
> 访问 localhost:808

## 生产端

1. 依赖

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>zk-sp-dubbo</artifactId>
        <groupId>com.com.ju</groupId>
        <version>0.0.1-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <artifactId>springboot-dubbo-provider</artifactId>


    <dependencies>
        <dependency>
            <groupId>org.apache.dubbo</groupId>
            <artifactId>dubbo-spring-boot-starter</artifactId>
            <version>2.7.3</version>
        </dependency>

        <dependency>
            <groupId>com.101tec</groupId>
            <artifactId>zkclient</artifactId>
            <version>0.10</version>
        </dependency>

        <dependency>
            <groupId>org.apache.curator</groupId>
            <artifactId>curator-framework</artifactId>
            <version>4.0.1</version>
        </dependency>

        <dependency>
            <groupId>org.apache.curator</groupId>
            <artifactId>curator-recipes</artifactId>
            <version>4.0.1</version>
        </dependency>

        <!-- 解除日志冲突 -->
        <dependency>
            <groupId>org.apache.zookeeper</groupId>
            <artifactId>zookeeper</artifactId>
            <version>3.4.13</version>
            <exclusions>
                <exclusion>
                    <groupId>org.slf4j</groupId>
                    <artifactId>slf4j-log4j12</artifactId>
                </exclusion>
            </exclusions>
        </dependency>

    </dependencies>


</project>
```

2. applcation.properties

```yml
server.port=8001
# 服务应用名称
dubbo.application.name=provider-server
# 注册服务中心地址
dubbo.registry.address=zookeeper://127.0.0.1:2181
#dubbo.config-center.address=zookeeper://127.0.0.1:2181
# 哪些服务需要被注册
dubbo.scan.base-packages=com.com.ju.service
```

3. TicketServiceImpl

```java
package com.ju.service;

import org.apache.dubbo.config.annotation.Service;
import org.springframework.stereotype.Component;

@Service     //在被扫描到的情况下 启动直接交给注册中心
@Component   //交给spring管理
public class TicketServiceImpl implements TicketService {
    @Override
    public String getTicket() {
        return "居泽龙";
    }
}
```

4. 主要的目录结构

![image-20201020112821374](/Users/juzelong/Documents/image-20201020112821374.png)

## 消费端

1. 依赖

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.3.4.RELEASE</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <groupId>com.com.ju</groupId>
    <artifactId>springboot-consumer-02</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>springboot-consumer-02</name>
    <description>Demo project for Spring Boot</description>

    <properties>
        <java.version>1.8</java.version>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>org.apache.dubbo</groupId>
            <artifactId>dubbo-spring-boot-starter</artifactId>
            <version>2.7.3</version>
        </dependency>


        <dependency>
            <groupId>com.com.ju</groupId>
            <artifactId>springboot-dubbo-provider</artifactId>
            <version>0.0.1-SNAPSHOT</version>
        </dependency>

        <dependency>
            <groupId>com.101tec</groupId>
            <artifactId>zkclient</artifactId>
            <version>0.10</version>
        </dependency>

        <dependency>
            <groupId>org.apache.curator</groupId>
            <artifactId>curator-framework</artifactId>
            <version>4.0.1</version>
        </dependency>

        <dependency>
            <groupId>org.apache.curator</groupId>
            <artifactId>curator-recipes</artifactId>
            <version>4.0.1</version>
        </dependency>

        <!-- 解除日志冲突 -->
        <dependency>
            <groupId>org.apache.zookeeper</groupId>
            <artifactId>zookeeper</artifactId>
            <version>3.4.13</version>
            <exclusions>
                <exclusion>
                    <groupId>org.slf4j</groupId>
                    <artifactId>slf4j-log4j12</artifactId>
                </exclusion>
            </exclusions>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
            <exclusions>
                <exclusion>
                    <groupId>org.junit.vintage</groupId>
                    <artifactId>junit-vintage-engine</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>
```

2. testController.java

```java
package com.ju.springbootconsumer02.com.ju.controller;

import com.ju.springbootconsumer02.com.ju.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class testController {

    @Autowired
    private UserService userService;


    @RequestMapping("/haha")
    @ResponseBody
    public String getService() {
        return userService.getTicket();
    }

}
```

3. userService

```java
package com.ju.springbootconsumer02.com.ju.controller;

import com.ju.springbootconsumer02.com.ju.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class testController {

    @Autowired
    private UserService userService;


    @RequestMapping("/haha")
    @ResponseBody
    public String getService() {
        return userService.getTicket();
    }

}
```

4. application.properties

```yml

server.port=8002

#消费者去哪里拿服务 需要暴露自己的名字
dubbo.application.name=consumer-server
#注册中心的地址
dubbo.registry.address=zookeeper://127.0.0.1:2181
```

> 说下自己的理解：
>
> zookeeper就是类似于一个记录服务注册信息和发现服务的地方
>
> dubbo其实本身是把注册中心这块抽象出来了，让各种软件都可以做存贮的介质，如zk，redis
>
> 生产者写完以后将自己的进程挂在zookeeper上
>
> 消费者写完以后通过zookeeper上拿到服务的进程通信地址，再用dubbo进行远程调用

# 2020.10.20

> 简单了解一下springcloud吧



# 2020.10.21 开放商城入驻手册

> 关于新供应商入驻的全部流程

**关于shop**：

1. 阿波罗配置支付code

exp:   10000:cmVkaXMK,10001:MLPE7Ub9

2. 新入驻的开放商城的角色

```sql
INSERT INTO `towngas_permissions`.`t_roles` (  `org_id`, `name`, `display_name`, `description`, `guard_name`, `status`, `remark`, `created_at`, `updated_at`, `enterprise_id` )VALUES (  0, '店铺管理员', '店铺管理员', '店铺管理员', 'shop', 1, '店铺管理员', '2020-07-14 23:40:23', '2020-07-17 18:17:13', 10001 );
```

3. 创建账号

> 直接后台操作

4. 角色赋权 记得把地址和bearer改一下

```pseudocode
curl --location --request GET 'http://pre-shop.mingqijia.com/api/manager/permissionRefresh' \
--header 'Authorization: bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwOlwvXC9wcmUtc2hvcC5taW5ncWlqaWEuY29tXC9hcGlcL21hbmFnZXJcL2xvZ2luIiwiaWF0IjoxNjAzMjYxMDgwLCJleHAiOjE2MDQ1NTcwODAsIm5iZiI6MTYwMzI2MTA4MCwianRpIjoiM2VSekhJWWFKa2VKVWEyUCIsInN1YiI6MTI0LCJwcnYiOiI4N2UwYWYxZWY5ZmQxNTgxMmZkZWM5NzE1M2ExNGUwYjA0NzU0NmFhIn0.6b6N1lhHCguI76EMFOMhTOtDPd3kYPBUIR9vUOV33kU' \
--header 'x-enterprise-id: 10001'
```

**关于supplier**:

1. 新建角色

```sql
INSERT INTO `towngas_permissions`.`t_roles` (  `org_id`, `name`, `display_name`, `description`, `guard_name`, `status`, `remark`, `created_at`, `updated_at`, `enterprise_id` )VALUES (  0, '供应商管理员', '供应商管理员', '供应商管理员', 'supplier', 1, '供应商管理员', '2020-07-14 23:40:23', '2020-07-17 18:17:13', 10001 );
```

2. 创建账号

> 直接后台操作

3. 角色赋权 记得把地址和bearer改一下

```pseudocode
curl --location --request GET 'http://pre-supplier.mingqijia.com/api/manager/permissionRefresh' \
--header 'Content-Type: application/json' \
--header 'Authorization: bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwOlwvXC9wcmUtc3VwcGxpZXIubWluZ3FpamlhLmNvbVwvYXBpXC9tYW5hZ2VyXC9sb2dpbiIsImlhdCI6MTYwMzI0NzA5MywiZXhwIjoxNjA0NTQzMDkzLCJuYmYiOjE2MDMyNDcwOTMsImp0aSI6IjJTZVI5dUhlTFliTU84dTYiLCJzdWIiOjMzLCJwcnYiOiI4N2UwYWYxZWY5ZmQxNTgxMmZkZWM5NzE1M2ExNGUwYjA0NzU0NmFhIn0.wWg2c_MuasmCFWLEsnycBne6NYlcEBFYE8wCLo2Ncxg' \
```

**当所有以上操作完成后，刷新一下角色缓存就可以了**

```pseudocode
curl --location --request DELETE 'http://pre-manage.mingqijia.com/api/common/clear/cache?type=permission' \
--header 'Accept: */*' \
--header 'Accept-Encoding: gzip, deflate' \
--header 'Cache-Control: no-cache' \
--header 'Connection: keep-alive' \
--header 'Content-Length: 0' \
--header 'token: 20deae2d63d914d92a'
```



# 2020.10.22 看病

> 中型分布式网站的简单架构图

![image-20201022142643370](/Users/juzelong/Documents/image-20201022142643370.png)

## springcloud! ========== 这是所有搭建的集合体 =============

![image-20201023174600796](/Users/juzelong/Documents/image-20201023174600796.png)



> 生产者和消费者搭建，全程回顾！

1. 总项目依赖设置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.example</groupId>
    <artifactId>spring-cloud</artifactId>
    <version>1.0-SNAPSHOT</version>
    <modules>
        <module>spring-cloud-api</module>
        <module>springcloud-provider-dept-8001</module>
    </modules>

    <!-- 打包方式 -->
    <packaging>pom</packaging>

    <!-- 版本号之类 -->
    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <maven.compiler.source>1.8</maven.compiler.source>
        <maven.compiler.target>1.8</maven.compiler.target>
        <junit.verison>4.13</junit.verison>
        <lombok.version>1.18.12</lombok.version>
        <log4j.version>1.2.17</log4j.version>
    </properties>

    <dependencyManagement>
        <dependencies>
            <!-- spring-cloud的依赖 -->
            <!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-dependencies -->
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>Hoxton.RELEASE</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>

            <!-- springboot -->
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-dependencies</artifactId>
                <version>2.3.4.RELEASE</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>

            <!-- 数据库 -->
            <dependency>
                <groupId>mysql</groupId>
                <artifactId>mysql-connector-java</artifactId>
                <version>8.0.21</version>
            </dependency>

            <!-- 数据源 -->
            <dependency>
                <groupId>com.alibaba</groupId>
                <artifactId>druid</artifactId>
                <version>1.2.1</version>
            </dependency>

            <!-- springboot 启动器 -->
            <dependency>
                <groupId>org.mybatis.spring.boot</groupId>
                <artifactId>mybatis-spring-boot-starter</artifactId>
                <version>2.1.3</version>
            </dependency>

            <!-- 主要用于日志和测试 -->
            <!-- junit -->
            <dependency>
                <groupId>junit</groupId>
                <artifactId>junit</artifactId>
                <version>${junit.verison}</version>
                <scope>test</scope>
            </dependency>

            <!-- lombok -->
            <dependency>
                <groupId>org.projectlombok</groupId>
                <artifactId>lombok</artifactId>
                <version>${lombok.version}</version>
            </dependency>

            <!-- log4j -->
            <dependency>
                <groupId>log4j</groupId>
                <artifactId>log4j</artifactId>
                <version>${log4j.version}</version>
            </dependency>

            <!-- logback -->
            <dependency>
                <groupId>ch.qos.logback</groupId>
                <artifactId>logback-core</artifactId>
                <version>1.2.3</version>
            </dependency>

        </dependencies>
    </dependencyManagement>

    <build>

    </build>

</project>
```

2. 提供者的api层



# 2020.10.26 eureka，ribbon 和 feign

## 搭建eureka

1. 导入依赖

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>spring-cloud</artifactId>
        <groupId>org.example</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <artifactId>spring-cloud-eureka-7001</artifactId>

    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-eureka-server</artifactId>
            <version>1.4.7.RELEASE</version>
        </dependency>

        <!-- 热部署工具 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
        </dependency>

    </dependencies>


</project>
```

2. yml

```yml
server:
  port: 7001

#eureka
eureka:
  instance:
    hostname: localhost  #eureka服务端的实例名称
  client:
    register-with-eureka: false #表示是否向eureka注册中心注册自己
    fetch-registry: false       # false 表示自己就是注册中心
    service-url: #监控页面
      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/
```

3. 访问http://localhost:7001/



![image-20201026094308781](/Users/juzelong/Documents/image-20201026094308781.png)

## erueka集群例子

1. 配置第一台

```yml
server:
  port: 7001

#eureka
eureka:
  instance:
    hostname: eureka7001.com  #eureka服务端的实例名称
  client:
    register-with-eureka: false #表示是否向eureka注册中心注册自己
    fetch-registry: false       # false 表示自己就是注册中心
    service-url: #监控页面
      #defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/
      defaultZone: http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/
```

2. 配置剩下的几台

```yml
server:
  port: 7002

#eureka
eureka:
  instance:
    hostname: eureka7002.com  #eureka服务端的实例名称
  client:
    register-with-eureka: false #表示是否向eureka注册中心注册自己
    fetch-registry: false       # false 表示自己就是注册中心
    service-url: #监控页面
      #defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/
      defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7003.com:7003/eureka/
```

```yml
server:
  port: 7003

#eureka
eureka:
  instance:
    hostname: eureka7003.com  #eureka服务端的实例名称
  client:
    register-with-eureka: false #表示是否向eureka注册中心注册自己
    fetch-registry: false       # false 表示自己就是注册中心
    service-url: #监控页面
      #defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/
      defaultZone: http://eureka7002.com:7002/eureka/,http://eureka7001.com:7001/eureka/
```

3. 配置完直接就可以了

![image-20201026140204087](/Users/juzelong/Documents/image-20201026140204087.png)



> 个人的理解，这其实就是一个集群，zookeeper貌似是单节点选举制，一个是保证可用性，一个是保证数据一致性

## cap



> 关于cap的一些问题解析

![image-20201026135231643](/Users/juzelong/Documents/image-20201026135231643.png)

![image-20201026135343648](/Users/juzelong/Documents/image-20201026135343648.png)

![image-20201026135410183](/Users/juzelong/Documents/image-20201026135410183.png)

![image-20201026135443406](/Users/juzelong/Documents/image-20201026135443406.png)

> 集成式负载均衡：nginx，
>
> 进程式负载均衡：rinbbon，
>
> 主要区别是，一个需要分发，一个是在消费端直接得知所有的服务，并自己按照算法直接访问

## 集成eureka

1. 启动类上增加配置

```java

//启动类
@SpringBootApplication
@EnableEurekaClient   //服务启动后自动注册到eureka
@EnableDiscoveryClient //服务发现
public class DeptProvider_8014 {
    public static void main(String[] args) {
        SpringApplication.run(DeptProvider_8014.class, args);
    }
}
```

2. yaml

```yml
#eureka 注册服务到哪里
eureka:
  client:
    service-url: #监控页面
      defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/
  instance:
    instance-id: springcloud-provider-dept-8016 #修改eureka中的默认描述信息

#info配置
info:
  app.name: ju-springcloud
  company.name: blog.ju.com
```

## eureka基础上增加负载均衡 ribbon

> 这个东西绝大多数都是在消费端做事情

> 简单配置：

```java
package com.ju.springcloud.config;

import org.springframework.cloud.client.loadbalancer.LoadBalanced;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;

@Configuration   //相当于spring中的applicationContext.yml
public class ConfigBean {
    //配置负载均衡
    @Bean
    @LoadBalanced //ribbon
    public RestTemplate getRestTemplate() {
        return new RestTemplate();
    }
    
}
```

> 一个注解直接搞定

## 自定义策略

1. 增加自己的策略类

```java
package com.ju.springcloud.myrule;

import com.netflix.client.config.IClientConfig;
import com.netflix.loadbalancer.AbstractLoadBalancerRule;
import com.netflix.loadbalancer.ILoadBalancer;
import com.netflix.loadbalancer.Server;

import java.util.List;
import java.util.concurrent.ThreadLocalRandom;

public class JuRandom extends AbstractLoadBalancerRule {
    private Integer total = 0;
    private Integer currentIndex = 0;


    public Server choose(ILoadBalancer lb, Object key) {
        if (lb == null) {
            return null;
        }
        Server server = null;

        while (server == null) {
            if (Thread.interrupted()) {
                return null;
            }
            List<Server> upList = lb.getReachableServers();
            List<Server> allList = lb.getAllServers();

            int serverCount = allList.size();
            if (serverCount == 0) {
                /*
                 * No servers. End regardless of pass, because subsequent passes
                 * only get more restrictive.
                 */
                return null;
            }

//            int index = chooseRandomInt(serverCount);
//            server = upList.get(index);

            if (total < 5) {
                server = upList.get(currentIndex);
                total++;
            } else {
                total = 0;
                currentIndex++;
                if (currentIndex >= upList.size()) {
                    currentIndex = 0;
                }
                server = upList.get(currentIndex);
            }



            if (server == null) {
                /*
                 * The only time this should happen is if the server list were
                 * somehow trimmed. This is a transient condition. Retry after
                 * yielding.
                 */
                Thread.yield();
                continue;
            }

            if (server.isAlive()) {
                return (server);
            }

            // Shouldn't actually happen.. but must be transient or a bug.
            server = null;
            Thread.yield();
        }

        return server;

    }

    protected int chooseRandomInt(int serverCount) {
        return ThreadLocalRandom.current().nextInt(serverCount);
    }

    @Override
    public Server choose(Object key) {
        return choose(getLoadBalancer(), key);
    }

    @Override
    public void initWithNiwsConfig(IClientConfig clientConfig) {
        // TODO Auto-generated method stub

    }
}

```

2. 把配置返回

```java
package com.ju.springcloud.myrule;

import com.netflix.loadbalancer.IRule;
import com.netflix.loadbalancer.RandomRule;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class JuRule {
    @Bean
    public IRule myRule() {
        return new JuRandom();
    }
}
```



> 启动类：

```java
package com.ju.springcloud;

import com.ju.springcloud.myrule.JuRule;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.cloud.netflix.ribbon.RibbonClient;

@SpringBootApplication
@EnableEurekaClient
//在微服务启动的时候就能去加载我们自定义的ribbon类
@RibbonClient(name = "SPRINGCLOUD-PROVIDER-DEPT", configuration = JuRule.class)
public class DeptConsumer_8013 {

    public static void main(String[] args) {
        SpringApplication.run(DeptConsumer_8013.class, args);
    }


```

## 面向注解和接口编程的feign组件

1. 引入依赖

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>spring-cloud</artifactId>
        <groupId>org.example</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <artifactId>spring-cloud-consumer-dept-feign</artifactId>

    <!-- 实体类+web -->
    <dependencies>

        <!-- feign -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-feign</artifactId>
            <version>1.4.7.RELEASE</version>
        </dependency>

        <!-- rinbbon -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-ribbon</artifactId>
            <version>1.4.7.RELEASE</version>
        </dependency>
        <!-- eureka发现服务去负载均衡 -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-eureka</artifactId>
            <version>1.4.7.RELEASE</version>
        </dependency>

        <dependency>
            <groupId>org.example</groupId>
            <artifactId>spring-cloud-api</artifactId>
            <version>1.0-SNAPSHOT</version>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
        </dependency>

    </dependencies>

</project>
```

2. api暴露层的服务

```java
package com.ju.springcloud.service;

import com.ju.springcloud.pojo.Dept;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.stereotype.Component;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@Component
@FeignClient(value = "SPRINGCLOUD-PROVIDER-DEPT")
public interface DeptClientService {
    @GetMapping("/dept/add")
    public boolean addDept(Dept dept);

    @GetMapping("/dept/get/{id}")
    public Dept queryById(@PathVariable("id") Long id);

    @PostMapping("/dept/getAll")
    public List<Dept> queryAll();

}
```

3. 消费端controller层 

```java
package com.ju.springcloud.controller;

import com.ju.springcloud.pojo.Dept;
import com.ju.springcloud.service.DeptClientService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController
public class DeptConsumerController {

    @Autowired
    private DeptClientService deptClientService;

    @RequestMapping("/consumer/dept/get/{id}")
    public Dept get(@PathVariable("id") Long id) {
        return deptClientService.queryById(id);
    }

    @RequestMapping("/consumer/dept/add")
    public boolean post(Dept dept) {
        return deptClientService.addDept(dept);
    }

    @RequestMapping("/consumer/dept/queryAll")
    public List<Dept> getDeptList(Dept dept) {
        return deptClientService.queryAll();
    }
}
```

4. 启动类:

```java
package com.ju.springcloud;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.cloud.openfeign.EnableFeignClients;
import org.springframework.context.annotation.ComponentScan;

@SpringBootApplication
@EnableEurekaClient
@EnableFeignClients(basePackages = {"com.ju.springcloud"})
public class FeignDeptConsumer_8013 {
    public static void main(String[] args) {
        SpringApplication.run(FeignDeptConsumer_8013.class, args);
    }
}
```

5. config:

```java
package com.ju.springcloud.config;

import org.springframework.cloud.client.loadbalancer.LoadBalanced;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;

@Configuration   //相当于spring中的applicationContext.yml
public class ConfigBean {
    //配置负载均衡
    @Bean
    @LoadBalanced //ribbon
    public RestTemplate getRestTemplate() {
        return new RestTemplate();
    }
    
}
```

> 我相信更多的人喜欢这种方式，只需要注解就可以直接面向接口编程了，比传统的看起来更容易被人接受

# 2020.10.27 hystrix的秘密

## hystrix 服务熔断与降级

> 关于概念

![image-20201027154008566](/Users/juzelong/Documents/image-20201027154008566.png)

> 实际操作

### 服务熔断

1. 导入依赖

```xml
 <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-hystrix</artifactId>
            <version>1.4.7.RELEASE</version>
        </dependency>
```

2. 控制改写

```java
package com.ju.controller;

import com.ju.service.DeptService;
import com.ju.springcloud.pojo.Dept;
import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.client.ServiceInstance;
import org.springframework.cloud.client.discovery.DiscoveryClient;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

import java.util.List;

@Controller
public class DeptController {

    @Autowired
    private DeptService deptService;

    //获取具体的微服务列表
    @Autowired
    private DiscoveryClient discoveryClient;


    @HystrixCommand(fallbackMethod = "hystrixQueryById")
    @RequestMapping("/dept/get/{id}")
    @ResponseBody
    public Dept queryById(@PathVariable("id") Long id){
        Dept dept = deptService.queryById(id);
        if (dept==null){
            throw new RuntimeException("id不存在");
        }

        return deptService.queryById(id);
    }

    //备选方案
    @ResponseBody
    public Dept hystrixQueryById(@PathVariable("id") Long id){
        return new Dept().
                setDeptNO(id).
                setDname("id不存在=>hystrix!!").
                setDb_source("no db");
    }
}

```

3. 启动类开启功能

```java
package com.ju;


import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.cloud.netflix.hystrix.EnableHystrix;

//启动类
@SpringBootApplication
@EnableEurekaClient   //服务启动后自动注册到eureka
@EnableDiscoveryClient //服务发现
@EnableCircuitBreaker //开启熔断措施
public class DeptProvider_8018 {
    public static void main(String[] args) {
        SpringApplication.run(DeptProvider_8018.class, args);
    }
}
```

### 服务降级

1. api层增加降级时候的提示 DeptClientFallBackFactory.java

```java
package com.ju.springcloud.service;


import com.ju.springcloud.pojo.Dept;
import feign.hystrix.FallbackFactory;
import org.springframework.stereotype.Component;

import java.util.List;

//降级
@Component
public class DeptClientFallBackFactory implements FallbackFactory {
    @Override
    public DeptClientService create(Throwable throwable) {
        return new DeptClientService() {
            @Override
            public boolean addDept(Dept dept) {
                return false;
            }

            @Override
            public Dept queryById(Long id) {
                return new Dept()
                        .setDeptNO(id)
                        .setDname("因为服务器不够用所以服务暂时关闭")
                        .setDb_source("没有数据");
            }

            @Override
            public List<Dept> queryAll() {
                return null;
            }
        };
    }
}

```

2. 消费端增加配置

```yml
server:
  port: 8017

#开启降级
feign:
  hystrix:
    enabled: true
#eureka配置
eureka:
  client:
    register-with-eureka: false  #不向服务中心注册自己
    service-url:
      defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/

```



### 关于监控

> 监控基于hystrix，因此监控的时候需要把包引入，并添加配置

1. 新建一个maven项目并导入依赖

```xml
<dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-hystrix</artifactId>
            <version>1.4.7.RELEASE</version>
        </dependency>

        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-hystrix-dashboard</artifactId>
            <version>1.4.7.RELEASE</version>
        </dependency>
```

2. 被监控的服务端必须拥有依赖包

```xml
<dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-hystrix</artifactId>
            <version>1.4.7.RELEASE</version>
        </dependency> 
<!-- 完善监控信息 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
```

3. 新项目配置 yml

```yml
server:
  port: 9001
```

4. 新项目配置启动类

```java
package com.ju.springcloud;


import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.cloud.netflix.hystrix.EnableHystrix;
import org.springframework.cloud.netflix.hystrix.dashboard.EnableHystrixDashboard;

//启动类
@SpringBootApplication
@EnableHystrixDashboard
public class hystrix_dashboad {
    public static void main(String[] args) {
        SpringApplication.run(hystrix_dashboad.class, args);
    }
}
```

5. 被监控的服务端启动类增加一个bean

```java
package com.ju;


import com.netflix.hystrix.HystrixMetrics;
import com.netflix.hystrix.contrib.metrics.eventstream.HystrixMetricsStreamServlet;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.web.servlet.ServletRegistrationBean;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.context.annotation.Bean;


//启动类
@SpringBootApplication
@EnableEurekaClient   //服务启动后自动注册到eureka
@EnableDiscoveryClient //服务发现
public class DeptProvider_8011 {
    public static void main(String[] args) {
        SpringApplication.run(DeptProvider_8011.class, args);
    }



    @Bean
    public ServletRegistrationBean getServlet() {
        HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet();
        ServletRegistrationBean registrationBean = new ServletRegistrationBean(streamServlet);
        registrationBean.setLoadOnStartup(1);
        registrationBean.addUrlMappings("/hystrix.stream");
        registrationBean.setName("HystrixMetricsStreamServlet");
        return registrationBean;
    }
}
```

6. 依次启动新项目，eureka，和服务端

访问地址http://localhost:8018/hystrix.stream,只要访问有数据即可

7. 页面展示![image-20201027170807910](/Users/juzelong/Documents/image-20201027170807910.png)

8. 各参数意义

![img](https://images2018.cnblogs.com/blog/1167856/201803/1167856-20180329162853894-1134441078.png)

> 个人理解：这个东西就是在要监控的服务端开了一个口子，用心跳方式把数据打印出来，然后在另外一个项目里监控这个地址就好了。



# 2020.10.28 zuul与config的故事

## zuul网关

1. 起一个新项目，并导入依赖

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>spring-cloud</artifactId>
        <groupId>org.example</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <artifactId>spring-cloud-zuul</artifactId>

    <dependencies>

        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-zuul</artifactId>
            <version>1.4.7.RELEASE</version>
        </dependency>

        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-hystrix</artifactId>
            <version>1.4.7.RELEASE</version>
        </dependency>

        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-hystrix-dashboard</artifactId>
            <version>1.4.7.RELEASE</version>
        </dependency>


        <!-- eureka -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-eureka</artifactId>
            <version>1.4.7.RELEASE</version>
        </dependency>
        <!-- 完善监控信息 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>

        <!-- 拿到我们的实体类 -->
        <dependency>
            <groupId>org.example</groupId>
            <artifactId>spring-cloud-api</artifactId>
            <version>1.0-SNAPSHOT</version>
        </dependency>

        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
        </dependency>

        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>druid</artifactId>
        </dependency>

        <dependency>
            <groupId>ch.qos.logback</groupId>
            <artifactId>logback-core</artifactId>
        </dependency>


        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-test</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-jetty</artifactId>
        </dependency>

        <!-- 热部署工具 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
        </dependency>



    </dependencies>

</project>
```

2. 配置

```yml
server:
  port: 9527
spring:
  application:
    name: spring-cloud-zuul
eureka:
  instance:
    instance-id: zuul9527.com
    prefer-ip-address: true
  client:
    service-url:
      defaultZone: http://eureka7002.com:7002/eureka/,http://eureka7001.com:7001/eureka/,http://eureka7001.com:7001/eureka/

info:
  app.name: ju-springcloud
  company.name: www.justudy.com
zuul:
  routes:
    mydept.serviceId: springcloud-provider-dept #将自己的信息替换
    mydept.path: /mydept/**
  ignored-services: springcloud-provider-dept #不能再使用这个路径访问
  prefix: /ju

```

3. 启动类

```java
package com.ju.springcloud;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.zuul.EnableZuulProxy;

@SpringBootApplication
@EnableZuulProxy
public class ZuulApplication {

    public static void main(String[] args) {
        SpringApplication.run(ZuulApplication.class, args);
    }
}

```

> 就这么简单。。这个东西主要的就2个用处，一个是路由配置，一个是过滤敏感信息
>
> 本身他是基于eureka，只要注册了服务在这上面，他就会根据服务的名称去查找服务
>
> **http://www.justudy.com:9527/springcloud-provider-dept/dept/get/1**
>
> 当然，他也可以利用配置隐藏或替换掉服务的名称
>
> ​    mydept.serviceId: springcloud-provider-dept #将自己的信息替换
> ​    mydept.path: /mydept/**
>
> **http://www.justudy.com:9527/mydept/dept/get/1**
>
> 还可以添加前缀
>
> ​    prefix: /ju
>
> **http://www.justudy.com:9527/ju/mydept/dept/get/1**



> 至此，所有的前期准备工作告一段落，开始正式看燃气项目的架构和数据结构

1. 我先简单说下他的架构，主要是springboot+dubbo，绝大多数都是用xml配置，没有选择注解
2. 后台关键技术：Jeecg Boot ，这个当然也是猜测，但是看下来应该是这样

> 因此我决定临时增加一下jeecg boot的一些学习

# 2020.10.29

> 知识简直无穷无尽，而且发展速度巨快，之前流行的dubbo+zookeeper遇到了一些阻碍，springcloud-eureka也不再开源，于是乎，出现了新的组件
>
> springcloud-alibaba，以nacos为中心，引申出来替代掉eureka-config-bus的注册与服务配置中心，冉冉升起。
>
> lets the game begin！





