# 1.2020.09.14  你好，世界



> 今天是回到公司的第一天，看看会发生什么吧

1. 首先是到家的需求，但是我绝大多数的东西忘记，需要回忆。

   pre环境做了白名单，因此数据访问收到了限制，需要将项目放到指定服务器才能访问，为了快速响应，我直接进行了修改发布。

   

2. 然后是对账单，德明和我对接。

   ![image-20200914151300090](/Users/juzelong/Library/Application Support/typora-user-images/image-20200914151300090.png)

​        既是命运，那就不见不散！



> 得到的信息是这个项目同事跟了一段时间，但是一直没有实质性的进展，我现在主要的目标是先把项目跑起来！

1. 先把maven的位置做好

![image-20200914155240563](/Users/juzelong/Library/Application Support/typora-user-images/image-20200914155240563.png)

> 会议纪要

1. 对账单帐不平的秘密  -> 帐平即可
2. 燃气云业务              -> 上线新东西
3. 电商                       -> 自组一套

> 结束语

项目依然跑不起来，这点必须记下

![image-20200914181115163](/Users/juzelong/Library/Application Support/typora-user-images/image-20200914181115163.png)



# 2020.09.15 对账业务

> 希望今天能把项目跑起来

![image-20200915094457874](/Users/juzelong/Library/Application Support/typora-user-images/image-20200915094457874.png)

这个项目的地址一直找不到，我也不清楚他们是怎么做的，或许他们的内网环境可以链接？

> 主要命令 跳过测试

```java
/Library/Java/JavaVirtualMachines/jdk1.8.0_221.jdk/Contents/Home/bin/java -Dmaven.multiModuleProjectDirectory=/Users/juzelong/project/vcc/gss -Dmaven.home=/Users/juzelong/project/maven/apache-maven-3.6.3 -Dclassworlds.conf=/Users/juzelong/project/maven/apache-maven-3.6.3/bin/m2.conf "-Dmaven.ext.class.path=/Applications/IntelliJ IDEA.app/Contents/plugins/maven/lib/maven-event-listener.jar" "-javaagent:/Applications/IntelliJ IDEA.app/Contents/lib/idea_rt.jar=60825:/Applications/IntelliJ IDEA.app/Contents/bin" -Dfile.encoding=UTF-8 -classpath /Users/juzelong/project/maven/apache-maven-3.6.3/boot/plexus-classworlds.license:/Users/juzelong/project/maven/apache-maven-3.6.3/boot/plexus-classworlds-2.6.0.jar org.codehaus.classworlds.Launcher -Didea.version2020.1.1 -s /Users/juzelong/project/maven/apache-maven-3.6.3/conf/vcc-settings.xml -Dmaven.repo.local=/Users/juzelong/project/repository -DskipTests=true install

```



> 项目可以打包成功了，但是我依然不知道整个步骤是怎样的

## 对账业务

1. **缴费流程**

![img](/Users/juzelong/Documents/0.png)

2. **对账流程**

![img](/Users/juzelong/Documents/0-20200915153218928.png)

3. 退费方案

   ![img](https://qqadapt.qpic.cn/txdocpic/0/fb34e592a64a365b61f2db79ff410d02/0?w=1288&h=1288&_type=png)

4. 源码说明![image-20200915153759344](/Users/juzelong/Documents/image-20200915153759344.png)
5. ![image-20200915153834582](/Users/juzelong/Documents/image-20200915153834582.png)
6.  

```
1. 扎帐(ReconciliatonCheckHandler)，对账时远程缓存必须有数据，否则对账失败抛异常。以远程单为准进行遍历扎帐，遍历本地单进行逐一对账。
2. 远程单支付成功：支付流水号相等？
    - 匹配支付状态、账单金额，统计远程订单数量和远程订单总额，本地订单数量（处理合并订单）和本地订单金额（优惠卡订单金额），设置对账成功；
    - 支付状态匹配，金额不匹配，统计远程订单数量和远程订单总额，本地订单数量（处理合并订单）和本地订单金额（优惠卡订单金额），设置对账数据异常等待人工处理或者对账成功不需要人工处理；
3. 远程单已退款：退款流水号与本地退款流水号相同，本地支付金额与远程退费金额相等？
    - 相等：设置对账成功，统计退费单数量和退费单总额，本地退费单量和本地退费总额（优惠卡退费总额）
    - 不等：设置对账数据异常等待人工处理标志或者设置退费成功标志，统计退费单数量和退费单总额，本地退费单量和本地退费总额（优惠卡退费总额）
4. 远程单支付失败：匹配支付流水号后，vcc将支付状态改为失败。    
    
```

7. 处理对账失败账单 

```
1. 系统配置是否自动平账，否则对账单为手动处理、对账失败
2. 查询上一步对账失败的的对账单（Reconciliation_state为V/R)，遍历对账单，针对每一条失败对账单(与支付单一一对应)：
    - 无支付单Id则说明需要对此笔进行补账，提示即可
    - 若为-平台已支付，vcc未支付-状态，则将对应支付单变更为已支付，业务状态变更为已完成，对账状态变更为已完成；若业务类型为IC卡充值(气量充值/金额充值)，则要对账户进行补气或补金额；
    - 若为-平台已退费，vcc已支付-状态，则将对应支付单变更为已退费，业务状态变更为已退费；若业务类型为IC卡充值(气量充值/金额充值)，则要检查用户是否已提气，未提气则查询余额，余额足够则气量冲正，否则判断是否冻结，若冻结则解冻退气冲正，否则标记人工处理；已提气则标记人工处理；
```

> 结束语： 不管是java还是业务，都是一头雾水，很难搞清楚来龙去脉，这对我而言的确算是个挑战



# 2020.09.15 java反射

## 关于java中的一些反射概念

> 由于知道业务的人下周才能回来，我觉得需要巩固一下我对java的知识

```java


import java.lang.annotation.*;
import java.lang.reflect.*;
import java.util.List;
import java.util.Map;

public class test3 {

    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException {
        //取得反射类
        Class<?> user = Class.forName("User");
        user.getName();
        System.out.println(user);
        //获取所有属性
        Field[] declaredFields = user.getDeclaredFields();
        for (Field declaredField : declaredFields) {
            System.out.println(declaredField);
        }

        //获得包括父类的所有public方法
        Method[] methods = user.getMethods();
        for (Method method : methods) {
            System.out.println(method);
        }
        //获得所有本类的方法
        Method[] declaredMethods = user.getDeclaredMethods();
        for (Method declaredMethod : declaredMethods) {
            System.out.println(declaredMethod);
        }

        //获取指定public方法 后面的参数是入参
        Method method = user.getMethod("getName", null);
        System.out.println(method);
        //获取所有方法
        Method method2 = user.getDeclaredMethod("getName", null);
        System.out.println(method2);

        //通过构造器获取类
        Class<?> user2 = Class.forName("User");
        Constructor<?> constructor = user2.getConstructor(String.class, int.class, int.class);
        User jzl = (User)constructor.newInstance("居泽龙", 18, 18);
        System.out.println(jzl);

        //调用方法
        Class<?> c1 = Class.forName("User");
        User user3 = (User)c1.newInstance();
        Method setNames = c1.getDeclaredMethod("setName", String.class);
        Method setAge = c1.getDeclaredMethod("setAge", int.class);
        Method setId = c1.getDeclaredMethod("setId", int.class);
        setNames.invoke(user3, "居泽龙");
        setAge.invoke(user3, 1);
        setId.invoke(user3, 2);
        System.out.println(user3.getName());


        Method getNameAndAge = c1.getDeclaredMethod("getNameAndAge", null);
        //私有方法开关
        getNameAndAge.setAccessible(true);
        int i = (int)getNameAndAge.invoke(user3, null);
        System.out.println(i);


        //获取结构化入参和返回值
        Method method5 = User.class.getMethod("test01", Map.class, List.class);

        Type[] genericParameterTypes = method5.getGenericParameterTypes();
        for (Type genericParameterType : genericParameterTypes) {
            System.out.println("#" + genericParameterType);
            if (genericParameterType instanceof ParameterizedType) {
                Type[] actualTypeArguments = ((ParameterizedType) genericParameterType).getActualTypeArguments();
                for (Type actualTypeArgument : actualTypeArguments) {
                    System.out.println(actualTypeArgument);
                }
            }
        }
        Type genericReturnType = method5.getGenericReturnType();
        if (genericReturnType instanceof ParameterizedType) {
            Type[] actualTypeArguments = ((ParameterizedType) genericReturnType).getActualTypeArguments();
            for (Type actualTypeArgument : actualTypeArguments) {
                System.out.println(actualTypeArgument);
            }
        }


        //获取注解
        Class user1 = Class.forName("User");
        Annotation[] annotations = user1.getAnnotations();
        for (Annotation annotation : annotations) {
            System.out.println(annotation);
        }

        TableJ annotation = (TableJ)user1.getAnnotation(TableJ.class);
        System.out.println(annotation.value());

        Field name = user1.getDeclaredField("name");

        Fieldj annotation1 = name.getAnnotation(Fieldj.class);

        System.out.println(annotation1.columnName());
        System.out.println(annotation1.type());
        System.out.println(annotation1.length());

    }
}

@TableJ(value = "ju")
class User {
    @Fieldj(columnName = "name", type= "varchar", length = 10)
    private String name;
    @Fieldj(columnName = "age", type= "int", length = 10)
    private int age;
    @Fieldj(columnName = "id", type= "int", length = 10)
    private int id;

    public User() {
    }

    public User(String name, int age, int id) {
        this.name = name;
        this.age = age;
        this.id = id;
    }

    private int getNameAndAge() {
        return this.age + this.id;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    public int getId() {
        return id;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public void setId(int id) {
        this.id = id;
    }

    @Override
    public String toString() {
        return "User{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", id=" + id +
                '}';
    }

    public Map<String, User> test01(Map<String, User> map, List<User> list) {
        return null;
    }

}


//类名注解
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@interface TableJ{
    String value();
}

//属性注解
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@interface Fieldj{
    String columnName();
    String type();
    int length();
}
```

> 视频看完了，总体的感觉这个东西是用来写框架，做到抽象和归一化处理。



> 看一下业务代码的主要作用吧

## 自动对账主流程

1. 拿到前一天的日期

```java
String reconDate = getReconciliationDate(date, org.getOrgCode());
```



2. 从t_vcc_payorder表查询有几种缴费渠道

        ```java
payTypes = billService.queryPayChannelByDate(org.getOrgCode(), reconDate);
//获取缴费记录
SELECT 
	DISTINCT(pay_type),
	channel_id
FROM
	`t_vcc_payorder`
WHERE
	org_code = :orgCode
AND pay_update_time >= :startTime
AND pay_update_time <= :endTime
        ```

3. 获取对账实体类 查询当天是否对过账，如果对过账则跳过（脚本是这样）

```java
pojo = getOrCreateReconciliation(org, reconDate, isTask, payTypes.get(i));
```





# 2020.09.16 业务源码整理

## 自动对账主流程

> 今天继续查看业务

1. 每天的每个渠道的对账刷新都有一个版本号，
2. 对账记录的状态

```java
/** 初始状态 */
	int STATE_INIT = 0x00000100;                 256
	
	/** 下载账单 */
	int STATE_DOWNLOAD_BILL = 0x00000101;        257
	
	/** 本地账单入库*/
	int STATE_LOCAL_BILL = 0x00000103;           259
	
	/** 扎帐*/
	int STATE_CHECK_BILL = 0x00000107;           263
	
	/** 消除错误账单 */
	int STATE_CLEAR_MISTAKE = 0x0000010f;        271
	
	/** 全部使用福利卡的订单入bill表 */
	int FREECA_PAYORDER_2_BILL = 0x0000011d;     285
	
	/** 生成对账账单数据*/
	int STATE_CREATE_BILL_FILE = 0x0000011f;     287
	
	/** 通知tcis */
	int STATE_NOTICE_TCIS = 0x0000013f;          319
	
	/** 结束 */
	int STATE_FINISH = 0x0000017f;               383
```

3. 如果没有对过账，那么生成一条记录，并建立临时表，如果本身就有记录的话，看状态来定是不是要清空临时表

```java
if (CommonUtil.isEmpty(pojoList)) {
				pojo.setVersion(1);
			} else {
				pojo.setVersion(pojoList.get(0).getVersion() + 1);
			}
			pojo.setReconDate(DateUtil.string2Date(reconDate));
			pojo.setStatus(BillContant.STATE_INIT);
			pojo.setOrgCode(org.getOrgCode());
			pojo.setPayChannelType(payType);
			billService.save(pojo);
			// 如果没有临时表，建临时表
			billService.createLocalBillTemp("t_temp_local_bill_" + org.getOrgCode());
			billService.createRemoteBillTemp("t_temp_remote_bill_" + org.getOrgCode());
}
//清空临时表，对账状态是259说明对账handler报错，不需要清空远程和本地临时表，257说明本地账单入临时表报错，远程订单已经入临时表
		if(pojo.getStatus()<BillContant.STATE_LOCAL_BILL) {
			billService.truncateTable("t_temp_local_bill_" + org.getOrgCode());
		}
		if(pojo.getStatus()<BillContant.STATE_DOWNLOAD_BILL) {
			billService.truncateTable("t_temp_remote_bill_" + org.getOrgCode());
		}
```

4. 循环渠道，循环脚本，查看执行过的记录

```java
List<BillHandler> handlerList = getHandlerList();
```

5. 根据状态来判断，是否要执行当前的脚本

```java
// 当前的状态是否已经执行过
					if (pojo.getStatus() < handler.getState()) {
						boolean flag = handler.handle(pojo);
						if (flag) {
							pojo.setStatus(handler.getState());
							LoggerUtil.info("执行后的状态pojo:{0}|{1}", pojo.getStatus(), handler.getState());
							pojo.setUpdateTime(DateUtil.getCurrentDate());
							// 更新
							billService.updateEntity(pojo);
						} else {
							// 记录日志 当前状态及后续不进行处理
							LoggerUtil.info("handler is end {0}|{1}|{2}", handler.getClass().getName(),
									org.getOrgCode(), pojo);
							break;
						}

					} else {
						// 记录日志 当前状态已处理
						LoggerUtil.info("handler is already execute {0}|{1}|{2}", handler.getClass().getName(),
								org.getOrgCode(), pojo);
						continue;
					}
```

## 对账细节

1. ```java
   DownloadBillHandler
   ```

        - 下载目标路径

```tex
#\u5546\u6237\u8BC1\u4E66\u5730\u5740
mch.certificate.path=/data/02/certificate/

#\u8D26\u5355\u4E0B\u8F7D\u5730\u5740
bill.download.path=/data/02/bill

#tcis\u8D26\u5355\u4FDD\u5B58\u5730\u5740
bill.file.path=/data/01

#tcis\u6587\u4EF6\u540C\u6B65\u5730\u5740
tcis.syncPath=/data/01/sync/
tcis3.0.syncPath=/data/01/
gas.transPath=/data/01/gasTransfer/
openapi.syncPath=/data/02/openApi/
```

1.1 微信支付

1.1.1 获取配置信息

```sql
select * from T_VCC_CONFIG_PARAM where group_code = 'PAY_WX' and param_code = 'APP_ID' and channel_id = 10010121//配置表

```

1.1.2 获取微信那边的xml信息，并解析，写到指定的文件夹

```java
    String bill_type = "ALL";
		WxPayConfig config = new WxPayConfig();
		config.setAppId(appid);
		config.setMchId(spid);
		config.setNotifyUrl(CommonUtil.getRandomChar(16));
		config.setMchKey(mchKey);

		WxPayBillResult result = downloadBills(trans_time, bill_type, null, null, config, filePath, path, fileName);
```

1.1.3 插入微信表

```java
StringBuffer buffer = new StringBuffer();
		buffer.append("insert into t_temp_remote_bill_");
		buffer.append(orgCode);
		buffer.append("(id,reconciliation_id,channel,pay_time,pay_trans_no,vcc_trans_no,pay_refund_no,vcc_refund_no,total_fee,pay_state,refund_fee,refund_state,pay_channel_type,mer_id)");
		buffer.append("values(?,?,?,?,?,?,?,?,?,?,?,?,?,?)");
```

1.1.4 小结：

> 主要的步骤就是 找到配置表 --> 请求微信账单 --> 下载微信账单 --> 写入临时表  



1.2 网付通对账 和**微信支付**步骤基本一致

1.3 德云思对账 和**微信支付**步骤基本一致

1.4 支付宝对账 和**微信支付**基本一致，但是数据结构所有变化

```java
Collection<Object[]> objcts, int batchCount) throws ServiceException, SQLException {
		StringBuffer buffer = new StringBuffer();
		buffer.append("insert into t_temp_remote_bill_");
		buffer.append(orgCode);
		buffer.append("(id,reconciliation_id,channel,pay_time,pay_trans_no,vcc_trans_no,pay_refund_no,vcc_refund_no,total_fee, pay_state, refund_fee, refund_state, pay_channel_type, mer_id,subs_id,busi_type)");
		buffer.append("values(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)");
		try {
			getGenericBaseDao().batchExecute(buffer.toString(), objcts, batchCount);
		}
		catch (DaoException e) {
			logger.info(e.getMessage());
			throw new ServiceException(e);
		}
```

1.5 支付宝生活 和**支付宝对账**基本一致

1.6 支付平台对账 感觉这个地方没有保存文件，其他的和**微信支付**步骤基本一致

> 自此，整个对账的第一步完成



2.LocalBillHandler

2.1  本地账单入库

2.1.1 插入支付信息

```sql
INSERT INTO t_temp_local_bill_$orgCode(
	id,
	reconciliation_id,
	payorder_id,
	subs_id,
	busi_type,
	channel,
	pay_channel_type,
	vcc_trans_no,
	pay_trans_no,
	tcis_trans_no,
	total_fee,
	discount_fee,
	pay_state,
	pay_time,
	biz_state,
	biz_time,
	org_code
)
SELECT
	upper(MD5(UUID())) AS id,
	:reconciliationId as reconciliation_id,
	po.id AS payorder_id,
	po.subs_id AS subs_id,
	po.busi_type AS busi_type,
	po.pay_type AS channel,
	:payChannelType AS pay_channel_type,
	po.trade_no AS vcc_trans_no,
	po.transaction_id AS pay_trans_no,
	po.biz_sn AS tcis_trans_no,
	po.total_fee AS total_fee,
	(SELECT SUM(discount_fee) FROM `t_vcc_payorder_freeca` WHERE (payorder_id = po.id or parent_payorder_id = po.id)) AS discount_fee,
	'C' AS pay_state,
	po.pay_completed_time AS pay_time,
	po.biz_state AS biz_state,
	po.biz_update_time AS biz_time,
	po.org_code AS org_code
FROM
	t_vcc_payorder po
WHERE
	((po.biz_state in ('O', 'C', 'W', 'G') and po.parent_payorder_id is null)
			or (po.biz_state = 'L' and po.busi_type = 'G'))
	
#if($payChannelType == "weixin")
	and po.pay_type like '%weixin%' and po.pay_type not like '%gnetpg%' and po.channel_id not like '%DYS%' and po.channel_id not like '%openApi%'
#end

#if($payChannelType == "gnetpg")
	and po.pay_type like '%gnetpg%'
#end

#if($payChannelType == "alipay")
	and po.pay_type = 'alipay'
#end

#if($payChannelType == "alipay_lifepay")
	and po.pay_type = 'alipay_lifepay'
#end

#if($payChannelType == "DYS")
	and (po.channel_id like '%DYS%' or po.channel_id like '%openApi%')
#end

#if($payChannelType == "payment")
	and po.pay_type like '%payment%'
#end

AND po.org_code = :orgCode
AND po.pay_completed_time >= :timeBegin
AND po.pay_completed_time <= :timeEnd
```

2.1.2 插入退款信息

```sql
INSERT INTO t_temp_local_bill_$orgCode(
	id,
	reconciliation_id,
	payorder_id,
	subs_id,
	busi_type,
	channel,
	pay_channel_type,
	vcc_trans_no,
	pay_trans_no,
	tcis_trans_no,
	vcc_refund_no,
	pay_refund_no,
	total_fee,
	discount_fee,
	pay_state,
	pay_time,
	biz_state,
	biz_time,
	org_code
)
SELECT
	upper(MD5(UUID())) AS id,
	:reconciliationId as reconciliation_id,
	po.id AS payorder_id,
	po.subs_id AS subs_id,
	po.busi_type AS busi_type,
	po.pay_type AS channel,
	:payChannelType AS pay_channel_type,
	po.trade_no AS vcc_trans_no,
	po.transaction_id AS pay_trans_no,
	po.biz_sn AS tcis_trans_no,
	po.out_refund_no AS vcc_refund_no,
	po.refund_no AS pay_refund_no,
	po.total_fee AS total_fee,
	(SELECT SUM(discount_fee) FROM `t_vcc_payorder_freeca` WHERE (payorder_id = po.id or parent_payorder_id = po.id)) AS discount_fee,
	po.pay_state AS pay_state,
	po.pay_update_time AS pay_time,
	po.biz_state AS biz_state,
	po.biz_update_time AS biz_time,
	po.org_code AS org_code
FROM
	t_vcc_payorder po
WHERE
	po.pay_state IN ('B','F')
AND po.busi_type != 'G'

#if($payChannelType == "weixin")
	 and po.pay_type like '%weixin%' and po.pay_type not like '%gnetpg%' and po.channel_id not like '%DYS%' and po.channel_id not like '%openApi%'
#end

#if($payChannelType == "gnetpg")
	and po.pay_type like '%gnetpg%'
#end

#if($payChannelType == "alipay")
	and po.pay_type = 'alipay'
#end

#if($payChannelType == "DYS")
	and (po.channel_id like '%DYS%' or po.channel_id like '%openApi%')
#end

#if($payChannelType == "payment")
	and po.pay_type like '%payment%'
#end

AND po.org_code = :orgCode
AND po.pay_update_time >= :timeBegin
AND po.pay_update_time <= :timeEnd
```

> 小结：这个类就是2个sql，将本地的数据加入要对比临时表之中

3. ReconciliatonCheckHandler

> 这个或许是真正的核心逻辑

3.1.1 拿到远程数据和本地数据

```sql
select 
id,
reconciliation_id,
payorder_id,
subs_id,
busi_type,
channel,
vcc_trans_no,
pay_trans_no,
tcis_trans_no,
vcc_refund_no,
pay_refund_no,
tcis_refund_no,
total_fee,
discount_fee,
pay_state,
pay_time,
biz_state,
biz_time,
org_code

 from t_temp_local_bill_$orgCode 
where reconciliation_id = :conId
#if($payState)
and pay_state = :payState
#end
```

```sql
select 
id,
reconciliation_id,
channel,
pay_channel_type,
pay_time,
pay_trans_no,
vcc_trans_no,
pay_refund_no,
vcc_refund_no,
total_fee,
pay_state,
refund_fee,
mer_id,
subs_id,
busi_type
from t_temp_remote_bill_$orgCode 
where channel = :orgCode 
and reconciliation_id = :reconciliationId
and pay_channel_type = :payChannelType

```

3.1.2 循环对比2张表的信息

```java
for (RemoteBillPojo remoteBill : remoteBills) {
				Boolean flag = false;// 用于标记是否有匹配
				
				for (LocalBillPojo localbill : localBills) {
   					//...       
        }
}
```

两者的关系主要建立于***PayTransNo***

3.1.2.1情况判断

```java
if (localbill.getPayTransNo().equalsIgnoreCase(remoteBill.getPayTransNo()))
```

3.1.2.2判断状态为***完成支付*** 且 ***金额相等***

```java
if (PayorderPojo.PAYSTATE_PAIDED.equals(localbill.getPayState()) 
									&& localbill.getRealPayFee() != null && remoteBill.getTotalFee() != null
									&& localbill.getRealPayFee().compareTo(remoteBill.getTotalFee()) == 0)
```

3.1.2.3 如果是合并缴费则添加所有的子单进入返回类，如果不是，只要添加一个主单即可

```java
if (BusiCodeDef.PAY_MERGE_FEE.equals(localbill.getBusiType())) {
									childPayorderNum = addChildPayOrderToBill(localbill.getPayorderId(), pojo, billList, true,
											BillContant.RECONCILIATION_STATE_CONFIRM, BillContant.FLAG_IS_NOT_MANUAL,
											"合并缴费", null, null, remoteBill.getPayTime(), PayorderPojo.PAYSTATE_PAIDED,
											remoteBill.getMerId(), localbill.getDiscountFee());
								} else {
									LoggerUtil.info("匹配账单金额是否相等[{0}]", localbill.getId());
									BillPojo billPojo =  createBillPojo(null, pojo, localbill, true, merId);
									billPojo.setManualFlag(BillContant.FLAG_IS_NOT_MANUAL);
									//对账成功
									billPojo.setPayReconciliationState(BillContant.RECONCILIATION_STATE_CONFIRM);
									billPojo.setParentVccTransNo(localbill.getVccTransNo());
									billPojo.setMerId(remoteBill.getMerId());
									billList.add(billPojo);
								}
```

3.1.2.4 增加统计数据

```java
// vcc支付单量和费用统计
								vccPayOrderNum = vccPayOrderNum + childPayorderNum;
								vccPayTotalFee = vccPayTotalFee + localbill.getRealPayFee();
								if (localbill.getDiscountFee() != null && localbill.getDiscountFee() > 0) {
									freecaTotalFee += localbill.getDiscountFee();
									freecaOrderNum ++;
								}
								break;
```

3.1.3.1情况判断

金额不匹配其他匹配

```java
if ((PayorderPojo.PAYSTATE_PAIDED.equals(localbill.getPayState())) 
      && localbill.getRealPayFee() != null && remoteBill.getTotalFee() != null
      && localbill.getRealPayFee().compareTo(remoteBill.getTotalFee()) != 0)
```





# 2020.09.17关于es的可视化工具

> 今天继续啃对账业务源码

> 啃到一半领导安排了我去寻找可以媲美phpadmin的es操作工具

1. 启动es，没有啥可说

![image-20200918143640470](/Users/juzelong/Documents/image-20200918143640470.png)

2. head

![image-20200918143734670](/Users/juzelong/Documents/image-20200918143734670.png)

> 这个工具算是上古时期的ui作品，他在建立索引的时候相对比较方便，其他的没有太多出彩的地方，开箱即用。

![image-20200918143952776](/Users/juzelong/Documents/image-20200918143952776.png)

3. Kibana

> 这个工具可以说是官方的标准工具，功能强大，很多的东西有提示和插件，剩下的需要自己钻研，但是并没有达到小白都可以操作的地步
>
> 我的结论是开发人员使用它时非常合适的，他完全可以作为一个主要的es查询工具。

![image-20200918144243901](/Users/juzelong/Documents/image-20200918144243901.png)

4. Dejavu

> 这个工具对于小白而言简直完美，应该可以胜任领导的要求

![image-20200918150721379](/Users/juzelong/Documents/image-20200918150721379.png)

5. ElasticHD

> 这个工具的首页大盘可谓惊艳，可以做为俯瞰整个集群状态的主要手段

![image-20200918151541624](/Users/juzelong/Documents/image-20200918151541624.png)



# 2020.09.21 mybatis的秘密

> 今天要么继续看对账源码，要么看spring，2选一，其实我更倾向于后者，毕竟前者等人回来再看或许事半功倍，但是我的耳机答不答应是个问题。

>  经过1个多小时的思想斗争，最终靠重启电脑解决了耳机连接的问题，那我继续我的spring+mybatis之旅吧

## mybatis的配置与helloworld

1. 新建maven项目并配置maven的三个地址

![image-20200921113757421](/Users/juzelong/Documents/image-20200921113757421.png)

2.  删除src并写入依赖

![image-20200921114427444](/Users/juzelong/Documents/image-20200921114427444.png)

3. 创建新模块后，子项目就可以拥有所有的依赖包

![image-20200921115545026](/Users/juzelong/Documents/image-20200921115545026.png)

4. 配置mybatis xml

![image-20200921134536331](/Users/juzelong/Documents/image-20200921134536331.png)

5. 编写mybatis工具类

![image-20200921135811598](/Users/juzelong/Documents/image-20200921135811598.png)

6. 编写pojo实体类，userDao接口，xml文件

   ![image-20200921145753745](/Users/juzelong/Documents/image-20200921145753745.png)

```java
package com.ju.pojo;

public class User {
    private int id;
    private String name;
    private String pwd;

    public User() {
    }

    public User(int id, String name, String pwd) {
        this.id = id;
        this.name = name;
        this.pwd = pwd;
    }

    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public String getPwd() {
        return pwd;
    }

    public void setId(int id) {
        this.id = id;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setPwd(String pwd) {
        this.pwd = pwd;
    }
}
```

```java
package com.ju.dao;

import com.ju.pojo.User;

import java.util.List;

public interface UserDao {
    List<User> getUserList();
}

```

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.ju.dao.UserDao">

<select id="getUserList" resultType="com.ju.pojo.User">
    select * from mybatis.user;
</select>

</mapper>
```

7.  编写测试用例

```java
package com.ju.dao;

import com.ju.pojo.User;
import com.ju.utils.MybatisUtils;
import org.apache.ibatis.session.SqlSession;
import org.junit.Test;

import java.util.List;

public class UserDaoTest {
    @Test
    public void test() {
        SqlSession sqlSession = MybatisUtils.getSqlSession();
        UserDao mapper = sqlSession.getMapper(UserDao.class);
        List<User> userList = mapper.getUserList();

        for (User user : userList) {
            System.out.println(user.getName());
        }

        sqlSession.close();

    }
}

```

8. 关于这个helloworld的一些坑

   - mapper的xml都必须写在核心配置文件中

   ![image-20200921150037187](/Users/juzelong/Documents/image-20200921150037187.png)

   - 链接的安全性开关，开启目前是会报错的![image-20200921150137645](/Users/juzelong/Documents/image-20200921150137645.png)

   - 如果不加入配置文件的话，很多东西会过滤而不加载

   ```java
        <build>
            <resources>
                <resource>
                    <directory>src/main/resources</directory>
                    <includes>
                        <include>**/*.properties</include>
                        <include>**/*.xml</include>
                    </includes>
                    <filtering>true</filtering>
                </resource>
                <resource>
                    <directory>src/main/java</directory>
                    <includes>
                        <include>**/*.properties</include>
                        <include>**/*.xml</include>
                    </includes>
                    <filtering>true</filtering>
                </resource>
            </resources>
        </build>
   
   ```

   - mysql8.0需要新的包和驱动

     ```java
     <dependency>
                 <groupId>mysql</groupId>
                 <artifactId>mysql-connector-java</artifactId>
                 <version>8.0.11</version>
             </dependency>
     ```

​          ![image-20200921150519237](/Users/juzelong/Documents/image-20200921150519237.png)

## mybatis CURD

1. 单个参数单个记录

```xml
<select id="getUserById" parameterType="int" resultType="com.ju.pojo.User">
        select * from mybatis.user where id = #{id};
    </select>
```

```java
User getUserById(int id)
```

2. 增加

```xml
<insert id="addUser" parameterType="com.ju.pojo.User">
        insert into user value(#{id}, #{name}, #{pwd})
    </insert>
```

```java
User getUserById(int id);
```

3. 改

```java
<update id="updateUser" parameterType="com.ju.pojo.User" >
        update mybatis.user set name = #{name}, pwd = #{pwd} where id = #{id} ;
    </update>
```

```java
int updateUser(User user);
```

4. 删

```java
<delete id="deleteUser" parameterType="int" >
        delete from mybatis.user where id = #{id} ;
    </delete>
```

```java
int deleteUser(int id);
```



## mybatis 配置

1. 属性配置 

![image-20200921165134778](/Users/juzelong/Documents/image-20200921165134778.png)

2. 引入属性

![image-20200921165600838](/Users/juzelong/Documents/image-20200921165600838.png)

3. 别名

![image-20200921170959301](/Users/juzelong/Documents/image-20200921170959301.png)

![image-20200921171011765](/Users/juzelong/Documents/image-20200921171011765.png)

**推荐使用扫描包的形式**

![image-20200921171315467](/Users/juzelong/Documents/image-20200921171315467.png)

4. 映射器的三种方式

![image-20200921174544760](/Users/juzelong/Documents/image-20200921174544760.png)

# 2020.9.22 对账业务校验sql

> 今天如果没有新的任务，继续学mybatis

## mybatis 属性名字段名不一致

![image-20200922100232349](/Users/juzelong/Documents/image-20200922100232349.png)

## 日志工厂

1. 标准配置

```java
<settings>
        <setting name="logImpl" value="STDOUT_LOGGING"/>
    </settings>
```



## log4j

1. 导入依赖

```java
<dependency>
            <groupId>log4j</groupId>
            <artifactId>log4j</artifactId>
            <version>1.2.17</version>
        </dependency>
```

2. 新建配置

![image-20200922105839642](/Users/juzelong/Documents/image-20200922105839642.png)

```java
#############
# 输出到控制台
#############

# log4j.rootLogger日志输出类别和级别：只输出不低于该级别的日志信息DEBUG < INFO < WARN < ERROR < FATAL
# WARN：日志级别     CONSOLE：输出位置自己定义的一个名字       logfile：输出位置自己定义的一个名字
log4j.rootLogger=DEBUG,CONSOLE,logfile
# 配置CONSOLE输出到控制台
log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender 
# 配置CONSOLE设置为自定义布局模式
log4j.appender.CONSOLE.Target=System.out
log4j.appender.CONSOLE.Threshold=DEBUG
log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout 
# 配置CONSOLE日志的输出格式  [frame] 2019-08-22 22:52:12,000  %r耗费毫秒数 %p日志的优先级 %t线程名 %C所属类名通常为全类名 %L代码中的行号 %x线程相关联的NDC %m日志 %n换行
log4j.appender.CONSOLE.layout.ConversionPattern=[frame] %d{yyyy-MM-dd HH:mm:ss,SSS} - %-4r %-5p [%t] %C:%L %x - %m%n

################
# 输出到日志文件中
################

# 配置logfile输出到文件中 文件大小到达指定尺寸的时候产生新的日志文件
log4j.appender.logfile=org.apache.log4j.RollingFileAppender
# 保存编码格式
log4j.appender.logfile.Encoding=UTF-8
# 输出文件位置此为项目根目录下的logs文件夹中
log4j.appender.logfile.File=logs/root.log
# 后缀可以是KB,MB,GB达到该大小后创建新的日志文件
log4j.appender.logfile.MaxFileSize=10MB
# 设置滚定文件的最大值3 指可以产生root.log.1、root.log.2、root.log.3和root.log四个日志文件
log4j.appender.logfile.MaxBackupIndex=3  
# 配置logfile为自定义布局模式
log4j.appender.logfile.layout=org.apache.log4j.PatternLayout
log4j.appender.logfile.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} %F %p %m%n

##########################
# 对不同的类输出不同的日志文件
##########################

log4j.appender.console=org.apache.log4j.ConsoleAppender

log4j.logger.org.mybatis=DEBUG
log4j.logger.java.sql=DEBUG
log4j.logger.java.sql.Statement=DEBUG
log4j.logger.java.sql.ResultSet=DEBUG
log4j.logger.java.sql.PreparedStatement=DEBUG
```

3. 简单使用

```java
import org.apache.log4j.Logger;
import org.junit.Test;

import java.util.List;

public class UserMapperTest {

    static Logger logger = Logger.getLogger(UserMapperTest.class);

    @Test
    public void testLog4j() {
        logger.info("info 进入了");
        logger.debug("debug 进入了");
        logger.error("error 进入了");
    }
}
```

## 简单分页

```java
List<User> getUserListByLimit(Map<String, Integer> map);
```

```java
<resultMap id="UseMap2" type="User">
        <result column="id" property="id" />
        <result column="name" property="name" />
        <result column="pwd" property="password" />
    </resultMap>
    <select id="getUserListByLimit" parameterType="map" resultMap="UseMap2">
        select * from mybatis.user limit #{startIndex}, #{pageSize}
    </select>
```

```java
 @Test
    public void testLimit() {
        SqlSession sqlSession = MybatisUtils.getSqlSession();
        UserMapper mapper = sqlSession.getMapper(UserMapper.class);

        HashMap<String, Integer> stringIntegerHashMap = new HashMap<String, Integer>();
        stringIntegerHashMap.put("startIndex", 0);
        stringIntegerHashMap.put("pageSize", 2);
        List<User> userList = mapper.getUserListByLimit(stringIntegerHashMap);

        for (User user : userList) {
            System.out.println(user);
        }

        sqlSession.close();

    }
```

## 关于对账的业务

> 开始

1. 缴费平台 -> vcc -> tcis

tcis生成缴费->vcc-> 缴费

查询业务的sql

```sql
select p.pay_completed_time 缴费时间,s.code 户号,p.total_fee 缴费金额,p.trade_no VCC流水号,p.busi_type
from t_vcc_payorder p
left join t_vcc_subs s on s.id=p.subs_id
where p.pay_completed_time >='2019-05-08 00:00:00' and p.pay_completed_time <'2019-06-01 00:00:00' 
and p.pay_type='alipay_lifepay' and p.org_code='YH0105' and p.pay_state in ('C') and p.id not in(
 select payorder_id from t_vcc_bill where reconciliation_id in
  (select id from t_vcc_reconciliation where pay_channel_type='alipay_lifepay' 
  and org_code='YH0105' and recon_date between '2019-05-08' and '2019-05-31'))
order by p.pay_completed_time
```



# 2020.9.23 mybatis完结

> 从昨天的对账业务来看，主要的是根据sql查出不对的地方，然后把不对的地方发送给运营即可，代码层面的改革目前有阻力，项目本地跑不起来，暂时先把mybatis看完

## Lombok插件

1. 导入依赖

```java
<dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>1.18.12</version>
            <scope>provided</scope>
        </dependency>
```

2. 安装idea插件
3. 可使用的注解

```javascript
@Getter and @Setter
@FieldNameConstants
@ToString
@EqualsAndHashCode
@AllArgsConstructor, @RequiredArgsConstructor and @NoArgsConstructor
@Log, @Log4j, @Log4j2, @Slf4j, @XSlf4j, @CommonsLog, @JBossLog, @Flogger, @CustomLog
@Data
@Builder
@SuperBuilder
@Singular
@Delegate
@Value
@Accessors
@Wither
@With
@SneakyThrows
@val
@var
experimental @var
@UtilityClass
Lombok config system
```

4. 开始使用

```java
package com.ju.pojo;

import lombok.*;

@Data                 // get set 几乎所有的东西
@AllArgsConstructor   // 有参构造器
@NoArgsConstructor    // 无参构造器
@EqualsAndHashCode    // equals和hashcode
@ToString             // toString
public class User {
    private int id;
    private String name;
    private String password;
}

```

## 多对一的两种方式

1. 根据结果映射

Xml:

```xml
<select id="getStudentList" resultMap="StudentTeacher">
    select * from mybatis.student;
</select>
    <resultMap id="StudentTeacher" type="Student">
        <result property="id" column="id" />
        <result property="name" column="name" />
        <association property="teacher" column="teacher_id" javaType="Teacher" select="getTeacher" />
    </resultMap>

    <select id="getTeacher" resultType="Teacher">
        select * from teacher where id = #{id}
    </select>
```

2. 根据字段自己去查询

Xml:

```xml
<select id="getStudentListWithTeacherName" resultMap="studentTeacherName">
    select s.id as student_id,s.name as student_name, t.name as teacher_name
       from student s left join teacher t
on t.id = s.teacher_id
</select>

    <resultMap id="studentTeacherName" type="Student">
        <result property="id" column="student_id"/>
        <result property="name" column="student_name"/>
        <association property="teacher" javaType="Teacher">
            <result property="name" column="teacher_name"/>
        </association>
    </resultMap>
```

Mapper:

```java
List<Student> getStudentList();
```

Pojo:

```java
package com.ju.pojo;

import lombok.Data;

@Data      // get set
public class Student {
    private int id;
    private String name;

    private Teacher teacher;
}
```

## 一对多

Xml:

```xml

<select id="getTeacher" resultMap="teacherStudent">
   select t.id as tid, t.name as tname, s.id as sid, s.name as sname, s.teacher_id from teacher t left join student s
on s.teacher_id = t.id where t.id = #{id}
</select>

    <resultMap id="teacherStudent" type="Teacher">
        <result property="name" column="tname"/>
        <result property="id" column="tid" />
        <collection property="students" ofType="Student">
            <result property="name" column="sname"/>
            <result property="id" column="sid"/>
            <result property="teacherId" column="teacher_id"/>
        </collection>
    </resultMap>
```

Mapper:

```java
@Test
    public void testGetTeacher() {
        SqlSession sqlSession = MybatisUtils.getSqlSession();
        TeacherMapper mapper = sqlSession.getMapper(TeacherMapper.class);

        Teacher teacher1 = mapper.getTeacher(1);

        System.out.println(teacher1);


        sqlSession.close();
    }
```

Pojo:

```java
@Data      // get set
public class Teacher {
    private int id;
    private String name;
    private List<Student> students;
}
```

```java
@Data      // get set
public class Student {
    private int id;
    private String name;
    private int teacherId;
}
```

## 动态sql

偷个懒 https://mybatis.org/mybatis-3/zh/dynamic-sql.htm

绝大多数标签官网有提到 但是sql片段没有，放在这里

```xml
    <sql id="studentT">
        select s.id as student_id,s.name as student_name, t.name as teacher_name
       from student s left join teacher t
on t.id = s.teacher_id
    </sql>

<select id="getStudentListWithTeacherName" resultMap="studentTeacherName">
    <include refid="studentT"/>
</select>
```

## 缓存相关

1. 一级缓存是默认开启的，所有的缓存都只是针对一个mapper.xml
2. 二级缓存开启 

```xml
<!-- 开启二级缓存 -->
    <cache
            eviction="FIFO"
            flushInterval="60000"
            size="512"
            readOnly="true"/>

    <select id="getUserById" parameterType="int" resultMap="UseMap" useCache="true">
        select * from mybatis.user where id = #{id};
    </select>
```

```java
@Test
    public void testGetId() {
        SqlSession sqlSession = MybatisUtils.getSqlSession();
        UserMapper mapper = sqlSession.getMapper(UserMapper.class);
        User userById = mapper.getUserById(1);
        System.out.println(userById);
        sqlSession.close();

        SqlSession sqlSession2 = MybatisUtils.getSqlSession();
        UserMapper mapper2 = sqlSession2.getMapper(UserMapper.class);
        User userById2 = mapper2.getUserById(1);
        System.out.println(userById2);
        sqlSession2.close();
    }
```

> 说不好听点，都是鸡肋，生命周期只存在**sqlSession**的开启和结束之中，太短了。
>
> 完结，撒花🎉
>
> 如果没有新任务，那我就继续我的spring之旅

# 2020.9.24 hello spring

> 暂时再看下spring吧，没想到spring的创始人是个音乐教授。

> spring的所有历史版本 https://repo.spring.io/release/org/springframework/spring/
>
> github地址 https://github.com/spring-projects/spring-framework/tree/5.2.x

1. 引入依赖

```xml
<!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc -->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-webmvc</artifactId>
    <version>5.2.9.RELEASE</version>
</dependency>
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-jdbc</artifactId>
    <version>5.2.9.RELEASE</version>
</dependency>
```

2. ![image-20200924141810629](/Users/juzelong/Documents/image-20200924141810629.png)
3. hello spring!

![image-20200925093258492](/Users/juzelong/Documents/image-20200925093258492.png)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">
    <!-- 使用spring来创建对象 -->
    <bean id="hello" class="com.ju.pojo.Hello" >
        <property name="str" value="Spring" />
    </bean>


</beans>
```

![image-20200925093333811](/Users/juzelong/Documents/image-20200925093333811.png)

```java
import com.ju.pojo.Hello;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class myTest {
    public static void main(String[] args) {
        //获取spring的上下文对象
        ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml");
        Hello hello = (Hello) context.getBean("hello");
        String str = hello.getStr();
        System.out.println(str);
    }
}
```

# 2020.9.25 nginx

> 稍微打断一下，今天看下基础知识

## nginx

> 我本地的nginx文件路径  /usr/local/Cellar/nginx/1.17.3_1/bin
>
> ​                                  /usr/local/etc/nginx

![image-20200925100507201](/Users/juzelong/Documents/image-20200925100507201.png)

1. 负载均衡

![](/Users/juzelong/Documents/image-20200925141051714.png)
1.1权重负载均衡:

![image-20200925141015216](/Users/juzelong/Documents/image-20200925141015216.png)

1.2 ip_hash模式（拿ip取模即可，但是运气不好可能造成取的模一直一样，造成倾斜）

![image-20200925141318686](/Users/juzelong/Documents/image-20200925141318686.png)

2. backup关键字 主要是所有相关服务器宕机以后，启动访问，最大的作用是在更新上代码的时候处理掉多服务器访问不一致的问题。

![image-20200925142319826](/Users/juzelong/Documents/image-20200925142319826.png)

3. 静态代理

![image-20200925144532330](/Users/juzelong/Documents/image-20200925144532330.png)

# 2020.9.27 一些基础知识的整理

## 单例模式中的各种实现模式

```java

//饿汉模式，很饿很着急，所以类加载时即创建实例对象
public class Singleton1 {
	
	private static Singleton1 singleton = new Singleton1();
	
	private Singleton1(){
		
	}
	
	public static Singleton1 getInstance(){
		return singleton;
	}
}
```

```java

//饱汉模式，很饱不着急，延迟加载，啥时候用啥时候创建实例，存在线程安全问题
public class Singleton2 {
 
	private static Singleton2 singleton;
	
	private Singleton2(){
		
	}
	
	public static synchronized Singleton2 getInstance(){
		if(singleton == null) 
			singleton = new Singleton2();
		return singleton;
	}
}

```

```java

//饱汉模式的双重锁模式，提高效率
public class Singleton3 {
	private static Singleton3 singleton;
	
	private Singleton3(){
		
	}
	
	public static Singleton3 getInstance(){
		if(singleton == null){
			synchronized(Singleton3.class){
				if(singleton == null){
					singleton = new Singleton3();
				}
			}
		}
		return singleton;
	}
}

```

> ***\*几种模式的比较：\****
>
> 
>
> ***\*1、饿汉模式\****是线程安全的，因为实例对象在类加载过程中就会被创建，在getInstance()方法中只是直接返回对象引用。之所以被称为“饿汉”，是因为这种模式创建实例对象比较“急”，真的是饿坏了……
>
> 好处：简单明了，无需关注线程安全问题。
>
> 缺点：如果在一个大环境下使用了过多的饿汉单例，则会生产出过多的实例对象，无论你是否要使用他们。
>
> ***\*2、饱汉模式\****不是线程安全的，因为是在需要的时候才会产生实例对象，生产之前会判断对象引用是否为空，这里，如果多个线程同时进入判断，就会生成多个实例对象，这是不符合单例的思想的。所以饱汉模式为了保证线程安全，就用synchronized关键字标识了方法。之所以被称为“饱汉”，因为它很饱，不急着生产实例，在需要的时候才会生产。
>
> 好处：延时加载，用的时候才会生产对象。
>
> 缺点：需要保证同步，付出效率的代价。
>
> ***\*3、双重锁模式\****，是饱汉模式的优化，进行双重判断，当已经创建过实例对象后就无需加锁，提高效率。也是一种推荐使用的方式。

## redis队列如何保证他的高可用性？

> 个人理解就是哨兵模式+集群可以解决大多数的场景问题。
>
> 关键字：master salver sentinel
> sentinel必须是奇数个节点，每个节点是一票，当检测到master挂了以后，自动开始发选票给salver，选出新的master

## innodb和myisam

> 先弄明白什么是二叉树和b+树

1. b树

> 这棵树的诞生是为了解决掉二叉树阶越高，查询磁盘的次数就越高的问题

1.1 b树的诞生过程

![image-20200927113304754](/Users/juzelong/Documents/image-20200927113304754.png)

![image-20200927113316927](/Users/juzelong/Documents/image-20200927113316927.png)

![image-20200927113333597](/Users/juzelong/Documents/image-20200927113333597.png)

1.2 MyISAM索引实现
![MyISAM主键索引](https://img-blog.csdn.net/20150527164101257)

> 本人自己的理解：mysiam索引就是自己将数据的地址存了下来，调的时候直接找地址就好了，辅助索引也一样，唯一的区别是主索引不能重复，辅助索引可以

1.3 InnoDB

![InnoDB主索引](https://img-blog.csdn.net/20150527165207200)

> 本人理解：innodb的主索引是将数据完整的保存在了索引当中(因此称之为聚族索引)，调的时候直接拿数据，而辅助索引是记录了主索引的值，因此不要用长字段做索引

## 如何防止超卖

> 简单来说就是加个version的乐观锁就可以了
>
> 查的时候先把version查出来，更新的时候带version查，查不到抛个错就结束了

## 如何保证幂等性

> 网上的说法很多，
>
> 1.乐观锁
>
> 2.防重表
>
> 3.分布式锁
>
> 4.token
>
> 但是所有的说法都是围绕着一个字：锁，来展开的，基本套路就是发送请求前就把资源放进redis，然后另外一个服务器拿到数据的时候验证这个资源。

> 这里插一句：如何解决掉快速的重复提交
>
> csrf，渲染模版的时候给个token，session或者redis里也加一个，后端对比提交过来的token，一样就执行，删掉，不一样或者不存在就是重复的提交。

## 如何解决供货商写了有货，下单了却没货的问题

> 挖个坑

## 继续我的spring之旅

1. ioc的完全体形态

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">
    <!-- 使用spring来创建对象 -->
    <bean id="mysql" class="Dao.UserDaoMysqlImpl" />
    <bean id="oracle" class="Dao.UserDaoOracleImpl" />
    <bean id="userService" class="Service.UserServiceImpl">
        <property name="userDao" ref="oracle" />
    </bean>
</beans>
```

```java
import Service.UserServiceImpl;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class testUserService {

    public static void main(String[] args) {

        //获取spring的上下文对象
        ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml");
        UserServiceImpl userService1 = (UserServiceImpl) context.getBean("userService");
        userService1.getUser();


    }
}
```

> 这种方式，只需要改xml，代码不需要做任何事情

> 小知识点：Spring会在启动的时候加载所有在xml中的类

2. spring的配置

```xml
    <bean id="userT" class="com.ju.pojo.UserT" name="user2,u3,u4">
        <constructor-arg name="name" value="play" />
    </bean>
```

![image-20200927172511479](/Users/juzelong/Documents/image-20200927172511479.png)

# 2020.9.28 Spring注解和静态代理

## lavarel的生命周期

![处理请求到响应过程](https://upload-images.jianshu.io/upload_images/2119758-ae9730b03f6ce607.png?imageMogr2/auto-orient/strip)

## spring中各种属性依赖注入的方式

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">
  
    <!-- 使用spring来创建对象 -->
    <bean id="address" class="com.ju.pojo.Address" >
        <property name="address" value="上海"/>
    </bean>
    <bean id="student" class="com.ju.pojo.Student">
        <property name="name" value="juzelong1"/>
        <property name="address" ref="address"/>
        <property name="books">
            <array>
                <value>红楼梦</value>
                <value>三国演义</value>
            </array>
        </property>
        <property name="hobbies">
            <list>
                <value>写代码</value>
                <value>听歌</value>
            </list>
        </property>
        <property name="card">
            <map>
                <entry key="1" value="中国银行"/>
                <entry key="2" value="工商银行"/>
            </map>
        </property>
        <property name="games">
            <set>
                <value>lol</value>
                <value>bob</value>
            </set>
        </property>
        <property name="wife">
            <null/>
        </property>
        <property name="info">
            <props>
                <prop key="driver">123</prop>
                <prop key="url">www.baidu.com</prop>
            </props>
        </property>
    </bean>

</beans>
```

```java
package com.ju.pojo;

@Data
public class Address {
    private String address;

   
}

```

```java
package com.ju.pojo;

import java.util.*;

@Data
public class Student {
    private String name;
    private Address address;
    private String[] books;
    private List<String> hobbies;
    private Map<String, String> card;
    private Set<String> games;
    private String wife;
    private Properties info;

    
}

```

## Spring中的注解开发

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd">

    <!-- 开启注解支持 -->
    <context:annotation-config/>

    <bean id="cat" class="com.ju.pojo.Cat"/>
    <bean id="dog" class="com.ju.pojo.Dog"/>
    <bean id="person" class="com.ju.pojo.Person"/>


</beans>
```

```java
package com.ju.pojo;

import org.springframework.beans.factory.annotation.Autowired;

public class Person {
    @Autowired
    private Cat cat;
    @Autowired
    private Dog dog;
    private String name;

    public Cat getCat() {
        return cat;
    }

    public void setCat(Cat cat) {
        this.cat = cat;
    }

    public Dog getDog() {
        return dog;
    }

    public void setDog(Dog dog) {
        this.dog = dog;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```

> 从上面可以看的出来，所有的东西用注解自动装配，不需要写任何的额外xml

> @Resource和@Autowired的区别，
>
> @Autowired是按照name来链接
>
> @Resource是按照name来，如果不存在，就按照类来找

2. 其他的注解如下

```java
package com.ju.pojo;

import org.springframework.context.annotation.Scope;
import org.springframework.stereotype.Component;

@Component
@Scope("singleton")
public class User {
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```

```java
package com.ju.dao;

import org.springframework.stereotype.Repository;

@Repository
public class UserDao {
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}

```

```java
package com.ju.controller;

import org.springframework.stereotype.Controller;

@Controller
public class UserController {
}

```

```java
package com.ju.service;

import org.springframework.stereotype.Service;

@Service
public class UserService {
}

```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd">

    <!-- 自动扫描 -->
    <context:component-scan base-package="com.ju" />
    <!-- 开启注解支持 -->
    <context:annotation-config/>
</beans>
```

> 注意，其实@Repository @Service @Component @Controller其实都是一样的功能，只是不通的模块用不同的单词来约束
> @Scope("singleton") 这个是单例模式的注解写法

## 静态代理模式

> 代理模式，是实现spring aop的底层逻辑

Client:

```java
public class Client {
    public static void main(String[] args) {
        Host host = new Host();
        Proxy proxy = new Proxy(host);
        proxy.rent();
    }
}
```

Host:

```java
public class Host implements Rent {

    public void rent() {
        System.out.println("房东租房子");
    }
}
```

Proxy:

```java
public class Proxy implements Rent {
    private Host host;

    public Proxy(Host host) {
        this.host = host;
    }

    public void rent() {
        look();
        this.host.rent();
    }

    public void look() {
        System.out.println("看看");
    }
}
```

Rent:

```java
public interface Rent {
    public void rent();
}
```

> 总的来说，代理模式就是为了各司其职，让底层的类和业务类彻底解偶。底层类不用关注公共的事件，只需要做好自己的事情就可以了。

# 2020.9.29 springAOP

## 动态代理

代理类核心

```java
package demo2;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class ProxyInvocationHandle implements InvocationHandler {

    private Object target;

    //代理谁
    public void setTarget(Object target) {
        this.target = target;
    }

    //获得代理
    public Object getProxy() {
        return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(), this);
    }

    //生成代理
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        log(method.getName());
        return method.invoke(target, args);
    }

    //加入aop方法
    public void log(String msg) {
        System.out.println("执行了"+ msg + "方法");
    }
}
```

被代理的真实类

```java
package demo2;

import demo1.Rent;

public class Host implements Rent {

    public void rent() {
        System.out.println("房东租房子");
    }
}
```

真实类的抽象接口

```java
package demo2;

public interface Rent {
    public void rent();
}
```

客户端调用

```java
package demo2;

import demo1.Rent;

public class Client {
    public static void main(String[] args) {
        Host host = new Host();
        ProxyInvocationHandle proxyInvocationHandle = new ProxyInvocationHandle();
        proxyInvocationHandle.setTarget(host);
        Rent rent = (Rent) proxyInvocationHandle.getProxy();
        rent.rent();
    }
}
```

> 这样就明白了，aop真正的做法是什么，主要是先有接口，后有实现，然后建立动态代理类，将实现丢给代理类，堆砌aop代码，再返回出来，就可以做出效果
>
> **动态代理，代理的是某一类业务的一个接口**
>
> **静态代理，代理的是某一个类**

![image-20200929110019688](/Users/juzelong/Documents/image-20200929110019688.png)

## springAOP实现

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd">

    <!-- 使用spring来创建对象 -->
    <bean id="userService" class="com.ju.service.userServiceImpl" />
    <bean id="log" class="com.ju.log.log" />
    <bean id="aftertLog" class="com.ju.log.AftertLog" />
    <bean id="diy" class="com.ju.diy.diy" />

    <!-- 方式一 原生spring api接口 -->
    <!--  aop的约束 -->
<!--    <aop:config>-->
<!--        切入点 -->
<!--        <aop:pointcut id="pointcut" expression="execution(* com.ju.service.userServiceImpl.*(..))"/>-->
<!--        <aop:advisor advice-ref="log" pointcut-ref="pointcut"/>-->
<!--        <aop:advisor advice-ref="aftertLog" pointcut-ref="pointcut"/>-->
<!--    </aop:config>-->


<!-- 方式二，自定义类进行aop切面 -->
<!--    <bean id="diy" class="com.ju.diy.diy" />-->
<!--    <aop:config>-->
<!--         自定义切面 -->
<!--        <aop:aspect ref="diy">-->
<!--            &lt;!&ndash; 切入点 &ndash;&gt;-->
<!--            <aop:pointcut id="point" expression="execution(* com.ju.service.userServiceImpl.*(..))"/>-->
<!--            <aop:before method="before" pointcut-ref="point"/>-->
<!--            <aop:after method="after" pointcut-ref="point"/>-->
<!--        </aop:aspect>-->
<!--    </aop:config>-->


    <!-- 方式三 注解方式 -->
    <aop:aspectj-autoproxy/>
</beans>
```

```java
package com.ju.log;

import org.springframework.aop.MethodBeforeAdvice;

import java.lang.annotation.Target;
import java.lang.reflect.Method;

//普通模式
public class log implements MethodBeforeAdvice {

    public void before(Method method, Object[] objects, Object target) throws Throwable {
        System.out.println(target.getClass().getName()+ "的" + method.getName() + "被执行了");
    }
}
```

```java
package com.ju.log;

import org.springframework.aop.AfterAdvice;
import org.springframework.aop.AfterReturningAdvice;

import java.lang.reflect.Method;
//普通模式
public class AftertLog implements AfterReturningAdvice {

    public void afterReturning(Object o, Method method, Object[] objects, Object target) throws Throwable {
        System.out.println(target.getClass().getName()+ "的" + method.getName() + "被执行了");
    }
}
```

```java
package com.ju.diy;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.After;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;


// 注解与自定义模式 不加注解就是自定义模式
@Aspect
public class diy {

    @Before("execution(* com.ju.service.userServiceImpl.*(..))")
    public void before() {
        System.out.println("方法执行前");
    }

    @After("execution(* com.ju.service.userServiceImpl.*(..))")
    public void after() {
        System.out.println("方法执行后");
    }

    @Around("execution(* com.ju.service.userServiceImpl.*(..))")
    public void around(ProceedingJoinPoint pj) throws Throwable {

        System.out.println("===环绕开始===");

        System.out.println(pj.getSignature());
        Object proceed = pj.proceed();

        System.out.println("===环绕结束===");

        System.out.println(proceed);

    }
}

```

```java
import com.ju.service.userService;
import com.ju.service.userServiceImpl;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

//调用
public class myTest {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml");
        //spring中是动态代理，所以只会代理接口
        userService userService = (userService)context.getBean("userService");
        userService.add();
    }
}
```

> 个人观点，注释比较简单，小项目可以用，大项目可以用第二种，第一种过于死板和



![image-20200929144519199](/Users/juzelong/Documents/image-20200929144519199.png)

> 10.1在家把剩下的mybatis整合以及springmvc看完，springboot年前过完，那1年多的java便不算是白学！

## 下了个面试视频

> 360大牛全面解读PHP面试

# 2020.9.31

> 给予了我个任务，主要的目的是了解以前的燃气云业务并设计出一套有自己思路的架构体系，感觉有点小鸭梨。



## 注册服务

### 原业务

1. 注册

   1. t_vcc_user_account账号表，流程是拿到手机号和user_id来比对，如果对不上直接抛错。
   2. 拿手机直接去库里查，如果差不多注册，如果查到了就给个标示继续向下。

   ```sql
   SELECT
   	u.id,
   	u.browser,
   	u.count,
   	u.create_time,
   	u.default_org_id,
   	u.ip,
   	u.last_login_time,
   	u.state,
   	u.mobile
   FROM
   	t_vcc_user u,
   	t_vcc_user_account ua
   WHERE
   	u.ID = ua.user_id
   AND ua.state = 'A'
   AND ua.type = :type
   AND ua.account = :account
   ```

   ```java
   if (userPojo != null) {
               	userPojo.setMobile(userInfo.getMobile());
                   MemberPojo memberPojo = userService.getMemberByUserId(userPojo.getId());
                   // 气户管理删除会员
                   if (memberPojo == null) {
                       memberPojo = BeanTransformUtil.userInfo2Member(userInfo, memberPojo);
                       memberPojo.setUserId(userPojo.getId());
                       memberPojo.setCode(account);
                       userService.save(memberPojo);
                   }
                   else {
                       logger.info(memberPojo.toString());
                       BeanTransformUtil.userInfo2Member(userInfo, memberPojo);
                       userService.updateEntity(memberPojo);
                   }
               }
               else {
                   // 新建账户
                   userPojo = BeanTransformUtil.userInfo2User(userInfo, null);
                   if (CommonContant.ACCT_TYPE_MOBILE.equals(accountType)) {
                       userPojo.setState(CommonContant.AVALIABLE);
                   }
                   userService.save(userPojo);
   
                   MemberPojo memberPojo = BeanTransformUtil.userInfo2Member(userInfo, null);
                   memberPojo.setUserId(userPojo.getId());
                   memberPojo.setCode(account);
                   userService.save(memberPojo);
   
                   addAccount(userPojo.getId(), account, accountType, null);
               }
   ```

   3. 关于添加用户

   > 暂停，还是先把基础补完再来吧。



# 2020.10.5 springMVC

## servlet

1. 主要依赖

```xml
<dependencies>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.12</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-webmvc</artifactId>
            <version>5.2.9.RELEASE</version>
        </dependency>
        <dependency>
            <groupId>javax.servlet</groupId>
            <artifactId>servlet-api</artifactId>
            <version>2.5</version>
        </dependency>
        <dependency>
            <groupId>javax.servlet.jsp</groupId>
            <artifactId>jsp-api</artifactId>
            <version>2.2</version>
        </dependency>
        <dependency>
            <groupId>javax.servlet</groupId>
            <artifactId>jstl</artifactId>
            <version>1.2</version>
        </dependency>
    </dependencies>
```

2. 创建项目并设置他为web项目

![image-20201006165757995](/Users/juzelong/Documents/image-20201006165757995.png)

3. 创建完毕后，会出现webinf文件夹

![image-20201006165905546](/Users/juzelong/Documents/image-20201006165905546.png)

4. 继承sevrlet类并重写方法

![image-20201006170030703](/Users/juzelong/Documents/image-20201006170030703.png)

5. web.xml添加配置

```xml
    <servlet>
        <servlet-name>hello</servlet-name>
        <servlet-class>com.ju.servlet.HelloServlet</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>hello</servlet-name>
        <url-pattern>/hello</url-pattern>
    </servlet-mapping>
```

6. 添加tomcat服务器

![image-20201006170132326](/Users/juzelong/Documents/image-20201006170132326.png)

7. 添加jsp页面

![image-20201006170220043](/Users/juzelong/Documents/image-20201006170220043.png)

8. 效果:

![image-20201006170248164](/Users/juzelong/Documents/image-20201006170248164.png)

































